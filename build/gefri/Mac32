# 1 "/Development/gefri/src/lightweights/shapes/gxShape.cpp"
# 1 "/Development/gefri/build/gefri//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/Development/gefri/src/lightweights/shapes/gxShape.cpp"
# 1 "../../src/lightweights/shapes/gxShape.h" 1



# 1 "../../src/lightweights/gxVisualViewElement.h" 1



# 1 "../../src/lightweights/gxViewElement.h" 1



# 1 "../../src/core/gxRect.h" 1



# 1 "/usr/include/c++/4.2.1/vector" 1 3
# 63 "/usr/include/c++/4.2.1/vector" 3
       
# 64 "/usr/include/c++/4.2.1/vector" 3

# 1 "/usr/include/c++/4.2.1/bits/functexcept.h" 1 3
# 41 "/usr/include/c++/4.2.1/bits/functexcept.h" 3
# 1 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++config.h" 1 3
# 41 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++config.h" 3
# 1 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/os_defines.h" 1 3
# 61 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/os_defines.h" 3
# 1 "/usr/include/unistd.h" 1 3 4
# 71 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/_types.h" 1 3 4
# 27 "/usr/include/_types.h" 3 4
# 1 "/usr/include/sys/_types.h" 1 3 4
# 32 "/usr/include/sys/_types.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 33 "/usr/include/sys/_types.h" 2 3 4
# 1 "/usr/include/machine/_types.h" 1 3 4
# 34 "/usr/include/machine/_types.h" 3 4
# 1 "/usr/include/i386/_types.h" 1 3 4
# 37 "/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef int __darwin_ptrdiff_t;





typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 35 "/usr/include/machine/_types.h" 2 3 4
# 34 "/usr/include/sys/_types.h" 2 3 4
# 58 "/usr/include/sys/_types.h" 3 4
struct __darwin_pthread_handler_rec
{
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[36]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[24]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[4]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[4]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[124]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[12]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[596]; };
# 94 "/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef struct _opaque_pthread_attr_t
   __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t
   __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t
   __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t
   __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t
   __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t
   __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t
   __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t
   __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t
   *__darwin_pthread_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
# 28 "/usr/include/_types.h" 2 3 4
# 39 "/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;



typedef unsigned long __darwin_wctype_t;
# 72 "/usr/include/unistd.h" 2 3 4
# 1 "/usr/include/sys/unistd.h" 1 3 4
# 138 "/usr/include/sys/unistd.h" 3 4
struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
# 73 "/usr/include/unistd.h" 2 3 4




typedef __darwin_dev_t dev_t;





typedef __darwin_gid_t gid_t;




typedef __darwin_intptr_t intptr_t;





typedef __darwin_mode_t mode_t;





typedef __darwin_off_t off_t;




typedef __darwin_pid_t pid_t;






typedef __darwin_size_t size_t;




typedef __darwin_ssize_t ssize_t;




typedef __darwin_uid_t uid_t;




typedef __darwin_useconds_t useconds_t;





typedef __darwin_uuid_t uuid_t;
# 414 "/usr/include/unistd.h" 3 4
extern "C" {

void _exit(int) __attribute__((__noreturn__));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);
int close(int) __asm("_" "close" "$UNIX2003");
size_t confstr(int, char *, size_t) __asm("_" "confstr" "$UNIX2003");
char *crypt(const char *, const char *);
char *ctermid(char *);
int dup(int);
int dup2(int, int);

void encrypt(char *, int) __asm("_" "encrypt" "$UNIX2003");



int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
int fchown(int, uid_t, gid_t);
int fchdir(int);
pid_t fork(void);
long fpathconf(int, int);
int fsync(int) __asm("_" "fsync" "$UNIX2003");
int ftruncate(int, off_t);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

long gethostid(void);
int gethostname(char *, size_t);
char *getlogin(void);
int getlogin_r(char *, size_t);
int getopt(int, char * const [], const char *) __asm("_" "getopt" "$UNIX2003");
pid_t getpgid(pid_t);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
pid_t getsid(pid_t);
uid_t getuid(void);
char *getwd(char *);
int isatty(int);
int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" "$UNIX2003");
int link(const char *, const char *);
int lockf(int, int, off_t) __asm("_" "lockf" "$UNIX2003");
off_t lseek(int, off_t, int);
int nice(int) __asm("_" "nice" "$UNIX2003");
long pathconf(const char *, int);
int pause(void) __asm("_" "pause" "$UNIX2003");
int pipe(int [2]);
ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread" "$UNIX2003");
ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite" "$UNIX2003");
ssize_t read(int, void *, size_t) __asm("_" "read" "$UNIX2003");
ssize_t readlink(const char * , char * , size_t);
int rmdir(const char *);
int setegid(gid_t);
int seteuid(uid_t);
int setgid(gid_t);
int setpgid(pid_t, pid_t);

pid_t setpgrp(void) __asm("_" "setpgrp" "$UNIX2003");



int setregid(gid_t, gid_t) __asm("_" "setregid" "$UNIX2003");
int setreuid(uid_t, uid_t) __asm("_" "setreuid" "$UNIX2003");
pid_t setsid(void);
int setuid(uid_t);
unsigned int
  sleep(unsigned int) __asm("_" "sleep" "$UNIX2003");
void swab(const void * , void * , ssize_t);
int symlink(const char *, const char *);
void sync(void);
long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
int truncate(const char *, off_t);
char *ttyname(int);

int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" "$UNIX2003");



useconds_t
  ualarm(useconds_t, useconds_t);
int unlink(const char *);
int usleep(useconds_t) __asm("_" "usleep" "$UNIX2003");
pid_t vfork(void);
ssize_t write(int, const void *, size_t) __asm("_" "write" "$UNIX2003");

extern char *optarg;
extern int optind, opterr, optopt;


# 1 "/usr/include/sys/select.h" 1 3 4
# 66 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/sys/appleapiopts.h" 1 3 4
# 67 "/usr/include/sys/select.h" 2 3 4
# 78 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 88 "/usr/include/sys/_structs.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};







struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 183 "/usr/include/sys/_structs.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}


static inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[_n/(sizeof(__int32_t) * 8)] & (1<<(_n % (sizeof(__int32_t) * 8))));
}
# 79 "/usr/include/sys/select.h" 2 3 4
# 87 "/usr/include/sys/select.h" 3 4
typedef __darwin_time_t time_t;




typedef __darwin_suseconds_t suseconds_t;




typedef __darwin_sigset_t sigset_t;
# 134 "/usr/include/sys/select.h" 3 4
extern "C" {


int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )






  __asm("_" "pselect" "$UNIX2003")


  ;


# 1 "/usr/include/sys/_select.h" 1 3 4
# 39 "/usr/include/sys/_select.h" 3 4
int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )






  __asm("_" "select" "$UNIX2003")


  ;
# 153 "/usr/include/sys/select.h" 2 3 4

}
# 520 "/usr/include/unistd.h" 2 3 4

void _Exit(int) __attribute__((__noreturn__));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void *brk(const void *);
int chroot(const char *);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdtablesize(void);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);
int gethostuuid(uuid_t, const struct timespec *);
mode_t getmode(const void *, mode_t);
int getpagesize(void) __attribute__((__const__));
char *getpass(const char *);
int getpeereid(int, uid_t *, gid_t *);
int getpgid(pid_t _pid);
int getsgroups_np(int *, uuid_t);
int getsid(pid_t _pid);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
void *sbrk(int);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey" "$UNIX2003");



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode" "$UNIX2003");
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);
# 602 "/usr/include/unistd.h" 3 4
int fgetattrlist(int,void*,void*,size_t,unsigned long);
int fsetattrlist(int,void*,void*,size_t,unsigned long);
int getattrlist(const char*,void*,void*,size_t,unsigned long) __asm("_" "getattrlist" "$UNIX2003");
int setattrlist(const char*,void*,void*,size_t,unsigned long) __asm("_" "setattrlist" "$UNIX2003");
int exchangedata(const char*,const char*,unsigned long);
int getdirentriesattr(int,void*,void*,size_t,unsigned long*,unsigned long*,unsigned long*,unsigned long);



struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int);

extern int optreset;


}
# 62 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/os_defines.h" 2 3


extern "C" {
# 89 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/os_defines.h" 3
extern void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1(void);
extern int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1(void);
extern void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);
extern int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1(void);


}
# 42 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++config.h" 2 3


# 1 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/cpu_defines.h" 1 3
# 45 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++config.h" 2 3
# 153 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++config.h" 3
namespace std {
# 165 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++config.h" 3
}
# 42 "/usr/include/c++/4.2.1/bits/functexcept.h" 2 3
# 1 "/usr/include/c++/4.2.1/exception_defines.h" 1 3
# 43 "/usr/include/c++/4.2.1/bits/functexcept.h" 2 3

namespace std {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

}
# 66 "/usr/include/c++/4.2.1/vector" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 1 3
# 66 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.2.1/cstring" 1 3
# 48 "/usr/include/c++/4.2.1/cstring" 3
       
# 49 "/usr/include/c++/4.2.1/cstring" 3


# 1 "/usr/include/c++/4.2.1/cstddef" 1 3
# 48 "/usr/include/c++/4.2.1/cstddef" 3
       
# 49 "/usr/include/c++/4.2.1/cstddef" 3


# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stddef.h" 1 3 4
# 152 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 52 "/usr/include/c++/4.2.1/cstddef" 2 3

namespace std {

  using ::ptrdiff_t;
  using ::size_t;

}
# 52 "/usr/include/c++/4.2.1/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 80 "/usr/include/string.h" 3 4
extern "C" {
void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);

char *stpcpy(char *, const char *);
char *strcasestr(const char *, const char *);

char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror" "$UNIX2003");
int strerror_r(int, char *, size_t);
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);

char *strnstr(const char *, const char *, size_t);

char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);



void *memccpy(void *, const void *, int, size_t);
char *strtok_r(char *, const char *, char **);
char *strdup(const char *);

int bcmp(const void *, const void *, size_t);
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);
int ffs(int);
int ffsl(long);
int fls(int);
int flsl(long);
char *index(const char *, int);
void memset_pattern4(void *, const void *, size_t);
void memset_pattern8(void *, const void *, size_t);
void memset_pattern16(void *, const void *, size_t);
char *rindex(const char *, int);
int strcasecmp(const char *, const char *);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
int strncasecmp(const char *, const char *, size_t);
char *strsep(char **, const char *);
char *strsignal(int sig);
void swab(const void * , void * , ssize_t);


}
# 53 "/usr/include/c++/4.2.1/cstring" 2 3
# 78 "/usr/include/c++/4.2.1/cstring" 3
namespace std {

  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }

}
# 67 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.2.1/climits" 1 3
# 48 "/usr/include/c++/4.2.1/climits" 3
       
# 49 "/usr/include/c++/4.2.1/climits" 3

# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/limits.h" 1 3 4






# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/syslimits.h" 1 3 4
# 8 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/limits.h" 2 3 4


# 1 "/usr/include/limits.h" 1 3 4
# 64 "/usr/include/limits.h" 3 4
# 1 "/usr/include/machine/limits.h" 1 3 4







# 1 "/usr/include/i386/limits.h" 1 3 4
# 40 "/usr/include/i386/limits.h" 3 4
# 1 "/usr/include/i386/_limits.h" 1 3 4
# 41 "/usr/include/i386/limits.h" 2 3 4
# 9 "/usr/include/machine/limits.h" 2 3 4
# 65 "/usr/include/limits.h" 2 3 4
# 1 "/usr/include/sys/syslimits.h" 1 3 4
# 66 "/usr/include/limits.h" 2 3 4
# 11 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/limits.h" 2 3 4
# 51 "/usr/include/c++/4.2.1/climits" 2 3
# 68 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.2.1/cstdlib" 1 3
# 48 "/usr/include/c++/4.2.1/cstdlib" 3
       
# 49 "/usr/include/c++/4.2.1/cstdlib" 3
# 72 "/usr/include/c++/4.2.1/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 61 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/Availability.h" 1 3 4
# 126 "/usr/include/Availability.h" 3 4
# 1 "/usr/include/AvailabilityInternal.h" 1 3 4
# 127 "/usr/include/Availability.h" 2 3 4
# 62 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/sys/wait.h" 1 3 4
# 79 "/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;
# 95 "/usr/include/sys/wait.h" 3 4
typedef __darwin_id_t id_t;
# 116 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/sys/signal.h" 1 3 4
# 81 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/signal.h" 1 3 4
# 34 "/usr/include/machine/signal.h" 3 4
# 1 "/usr/include/i386/signal.h" 1 3 4
# 39 "/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 55 "/usr/include/i386/signal.h" 3 4
# 1 "/usr/include/i386/_structs.h" 1 3 4
# 56 "/usr/include/i386/signal.h" 2 3 4
# 35 "/usr/include/machine/signal.h" 2 3 4
# 82 "/usr/include/sys/signal.h" 2 3 4
# 154 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 57 "/usr/include/sys/_structs.h" 3 4
# 1 "/usr/include/machine/_structs.h" 1 3 4
# 31 "/usr/include/machine/_structs.h" 3 4
# 1 "/usr/include/i386/_structs.h" 1 3 4
# 38 "/usr/include/i386/_structs.h" 3 4
# 1 "/usr/include/mach/i386/_structs.h" 1 3 4
# 43 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 89 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 147 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 191 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 210 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 232 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};
# 308 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
    unsigned int __trapno;
    unsigned int __err;
    unsigned int __faultvaddr;
};
# 326 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 358 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 413 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};
# 517 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    unsigned int __trapno;
    unsigned int __err;
    __uint64_t __faultvaddr;
};
# 535 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 39 "/usr/include/i386/_structs.h" 2 3 4
# 48 "/usr/include/i386/_structs.h" 3 4
struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};
# 68 "/usr/include/i386/_structs.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};
# 94 "/usr/include/i386/_structs.h" 3 4
typedef struct __darwin_mcontext32 *mcontext_t;
# 32 "/usr/include/machine/_structs.h" 2 3 4
# 58 "/usr/include/sys/_structs.h" 2 3 4
# 75 "/usr/include/sys/_structs.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
# 128 "/usr/include/sys/_structs.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext32 *uc_mcontext;



};
# 218 "/usr/include/sys/_structs.h" 3 4
typedef struct __darwin_sigaltstack stack_t;
# 227 "/usr/include/sys/_structs.h" 3 4
typedef struct __darwin_ucontext ucontext_t;
# 155 "/usr/include/sys/signal.h" 2 3 4
# 163 "/usr/include/sys/signal.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 181 "/usr/include/sys/signal.h" 3 4
union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 292 "/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 354 "/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 371 "/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 390 "/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 412 "/usr/include/sys/signal.h" 3 4
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 117 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 76 "/usr/include/sys/resource.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 77 "/usr/include/sys/resource.h" 2 3 4
# 88 "/usr/include/sys/resource.h" 3 4
typedef __uint64_t rlim_t;
# 144 "/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 155 "/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 215 "/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 237 "/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int);

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" "$UNIX2003");
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int);

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" "$UNIX2003");
}
# 118 "/usr/include/sys/wait.h" 2 3 4
# 193 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/machine/endian.h" 1 3 4
# 37 "/usr/include/machine/endian.h" 3 4
# 1 "/usr/include/i386/endian.h" 1 3 4
# 99 "/usr/include/i386/endian.h" 3 4
# 1 "/usr/include/sys/_endian.h" 1 3 4
# 124 "/usr/include/sys/_endian.h" 3 4
# 1 "/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((_data << 8) | (_data >> 8));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{



    __asm__ ("bswap   %0" : "+r" (_data));
    return _data;

}
# 78 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    __asm__ ("bswap   %%eax\n\t"
             "bswap   %%edx\n\t"
             "xchgl   %%eax, %%edx"
             : "+A" (_data));
    return _data;
}
# 67 "/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 125 "/usr/include/sys/_endian.h" 2 3 4
# 100 "/usr/include/i386/endian.h" 2 3 4
# 38 "/usr/include/machine/endian.h" 2 3 4
# 194 "/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 254 "/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait" "$UNIX2003");
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" "$UNIX2003");

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" "$UNIX2003");


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/alloca.h" 1 3 4
# 35 "/usr/include/alloca.h" 3 4
extern "C" {
void *alloca(size_t);
}
# 68 "/usr/include/stdlib.h" 2 3 4
# 81 "/usr/include/stdlib.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;




typedef __darwin_rune_t rune_t;
# 97 "/usr/include/stdlib.h" 3 4
typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 134 "/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 144 "/usr/include/stdlib.h" 3 4
extern "C" {
void abort(void) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t);
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod" "$UNIX2003");
float strtof(const char *, char **) __asm("_" "strtof" "$UNIX2003");
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **) ;

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system" "$UNIX2003");
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv" "$UNIX2003");
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv" "$UNIX2003");

void setkey(const char *) __asm("_" "setkey" "$UNIX2003");



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" "$UNIX2003");






# 1 "/usr/include/machine/types.h" 1 3 4
# 37 "/usr/include/machine/types.h" 3 4
# 1 "/usr/include/i386/types.h" 1 3 4
# 70 "/usr/include/i386/types.h" 3 4
# 1 "/usr/include/i386/_types.h" 1 3 4
# 71 "/usr/include/i386/types.h" 2 3 4







typedef signed char int8_t;

typedef unsigned char u_int8_t;


typedef short int16_t;

typedef unsigned short u_int16_t;


typedef int int32_t;

typedef unsigned int u_int32_t;


typedef long long int64_t;

typedef unsigned long long u_int64_t;




typedef int32_t register_t;
# 109 "/usr/include/i386/types.h" 3 4
typedef unsigned long uintptr_t;




typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;
# 38 "/usr/include/machine/types.h" 2 3 4
# 256 "/usr/include/stdlib.h" 2 3 4
# 267 "/usr/include/stdlib.h" 3 4
u_int32_t
  arc4random(void);
void arc4random_addrandom(unsigned char *dat, int datlen);
void arc4random_stir(void);

int atexit_b(void (^)(void));
void *bsearch_b(const void *, const void *, size_t,
     size_t, int (^)(const void *, const void *));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((deprecated,visibility("default")));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int heapsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *));

int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int mergesort_b(void *, size_t, size_t,
     int (^)(const void *, const void *));

void psort(void *, size_t, size_t,
     int (*)(const void *, const void *));

void psort_b(void *, size_t, size_t,
     int (^)(const void *, const void *));

void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));

void qsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *));

void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg;
void *valloc(size_t);






}
# 73 "/usr/include/c++/4.2.1/cstdlib" 2 3
# 104 "/usr/include/c++/4.2.1/cstdlib" 3
namespace std {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 161 "/usr/include/c++/4.2.1/cstdlib" 3
namespace __gnu_cxx {


  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 194 "/usr/include/c++/4.2.1/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

}

namespace std {


  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;

}
# 69 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/4.2.1/iosfwd" 1 3
# 42 "/usr/include/c++/4.2.1/iosfwd" 3
       
# 43 "/usr/include/c++/4.2.1/iosfwd" 3


# 1 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++locale.h" 1 3
# 45 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++locale.h" 3
       
# 46 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++locale.h" 3

# 1 "/usr/include/c++/4.2.1/clocale" 1 3
# 48 "/usr/include/c++/4.2.1/clocale" 3
       
# 49 "/usr/include/c++/4.2.1/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 40 "/usr/include/locale.h" 3 4
# 1 "/usr/include/_locale.h" 1 3 4
# 43 "/usr/include/_locale.h" 3 4
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};





extern "C" {
struct lconv *localeconv(void);
}
# 41 "/usr/include/locale.h" 2 3 4
# 52 "/usr/include/locale.h" 3 4
extern "C" {
char *setlocale(int, const char *);
}
# 52 "/usr/include/c++/4.2.1/clocale" 2 3





namespace std {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 48 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++locale.h" 2 3

# 1 "/usr/include/c++/4.2.1/cstdio" 1 3
# 48 "/usr/include/c++/4.2.1/cstdio" 3
       
# 49 "/usr/include/c++/4.2.1/cstdio" 3




# 1 "/usr/include/stdio.h" 1 3 4
# 70 "/usr/include/stdio.h" 3 4
typedef __darwin_va_list va_list;
# 87 "/usr/include/stdio.h" 3 4
typedef __darwin_off_t fpos_t;
# 98 "/usr/include/stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 132 "/usr/include/stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {

extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;



}
# 248 "/usr/include/stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * , const char * ) __asm("_" "fopen" "$UNIX2003");

int fprintf(FILE * , const char * , ...) ;
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" "$UNIX2003");
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
     FILE * ) __asm("_" "freopen" "$UNIX2003");
int fscanf(FILE * , const char * , ...) ;
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite" "$UNIX2003");
int getc(FILE *);
int getchar(void);
char *gets(char *);

extern const int sys_nerr;
extern const char *const sys_errlist[];

void perror(const char *);
int printf(const char * , ...) ;
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) ;
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) ;
int sscanf(const char * , const char * , ...) ;
FILE *tmpfile(void);
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) ;
int vprintf(const char * , va_list) ;
int vsprintf(char * , const char * , va_list) ;

int asprintf(char **, const char *, ...) ;
int vasprintf(char **, const char *, va_list) ;

}







extern "C" {
char *ctermid(char *);

char *ctermid_r(char *);




FILE *fdopen(int, const char *) __asm("_" "fdopen" "$UNIX2003");


char *fgetln(FILE *, size_t *);

int fileno(FILE *);
void flockfile(FILE *);

const char
 *fmtcheck(const char *, const char *);
int fpurge(FILE *);

int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);

int getw(FILE *);

int pclose(FILE *);



FILE *popen(const char *, const char *) __asm("_" "popen" "$UNIX2003");

int putc_unlocked(int, FILE *);
int putchar_unlocked(int);

int putw(int, FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);

int snprintf(char * , size_t, const char * , ...) ;
char *tempnam(const char *, const char *) __asm("_" "tempnam" "$UNIX2003");
int vfscanf(FILE * , const char * , va_list) ;
int vscanf(const char * , va_list) ;
int vsnprintf(char * , size_t, const char * , va_list) ;
int vsscanf(const char * , const char * , va_list) ;

FILE *zopen(const char *, const char *, int);

}





extern "C" {
FILE *funopen(const void *,
  int (*)(void *, char *, int),
  int (*)(void *, const char *, int),
  fpos_t (*)(void *, fpos_t, int),
  int (*)(void *));
}
# 383 "/usr/include/stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) ;
int __swbuf(int, FILE *);
}







static inline int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 54 "/usr/include/c++/4.2.1/cstdio" 2 3
# 98 "/usr/include/c++/4.2.1/cstdio" 3
namespace std {

  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;

}
# 155 "/usr/include/c++/4.2.1/cstdio" 3
namespace __gnu_cxx {
# 170 "/usr/include/c++/4.2.1/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;


}

namespace std {

  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;

}
# 50 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++locale.h" 2 3
# 1 "/usr/include/c++/4.2.1/cstdarg" 1 3
# 48 "/usr/include/c++/4.2.1/cstdarg" 3
       
# 49 "/usr/include/c++/4.2.1/cstdarg" 3


# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stdarg.h" 1 3 4
# 43 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 52 "/usr/include/c++/4.2.1/cstdarg" 2 3






namespace std {

  using ::va_list;

}
# 51 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++locale.h" 2 3



namespace std {

  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, __null);
    char* __sav = __null;
    if (std::strcmp(__old, "C"))
      {
 __sav = new char[std::strlen(__old) + 1];
 std::strcpy(__sav, __old);
 std::setlocale(4, "C");
      }

    va_list __args;
    __builtin_va_start(__args,__fmt);


    const int __ret = std::vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }

}
# 46 "/usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++io.h" 1 3
# 43 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++io.h" 3
# 1 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr.h" 1 3
# 33 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 114 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr.h" 3
# 1 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr-default.h" 1 3
# 43 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 57 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/pthread_impl.h" 1 3 4
# 58 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/sched.h" 1 3 4
# 30 "/usr/include/sched.h" 3 4
extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 69 "/usr/include/time.h" 3 4
# 1 "/usr/include/_structs.h" 1 3 4
# 24 "/usr/include/_structs.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 25 "/usr/include/_structs.h" 2 3 4
# 70 "/usr/include/time.h" 2 3 4







typedef __darwin_clock_t clock_t;
# 90 "/usr/include/time.h" 3 4
struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 113 "/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" "$UNIX2003");

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" "$UNIX2003");
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" "$UNIX2003");
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" "$UNIX2003");
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" "$UNIX2003");
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep" "$UNIX2003");

}
# 61 "/usr/include/pthread.h" 2 3 4
# 69 "/usr/include/pthread.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;




typedef __darwin_pthread_condattr_t pthread_condattr_t;




typedef __darwin_pthread_key_t pthread_key_t;




typedef __darwin_pthread_mutex_t pthread_mutex_t;




typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;




typedef __darwin_pthread_once_t pthread_once_t;




typedef __darwin_pthread_rwlock_t pthread_rwlock_t;




typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;




typedef __darwin_pthread_t pthread_t;






typedef __darwin_mach_port_t mach_port_t;
# 148 "/usr/include/pthread.h" 3 4
extern "C" {
# 244 "/usr/include/pthread.h" 3 4
int pthread_atfork(void (*)(void), void (*)(void),
                      void (*)(void));
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getdetachstate(const pthread_attr_t *,
          int *);
int pthread_attr_getguardsize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_getinheritsched(const pthread_attr_t * ,
           int * );
int pthread_attr_getschedparam(const pthread_attr_t * ,
                                     struct sched_param * );
int pthread_attr_getschedpolicy(const pthread_attr_t * ,
          int * );
int pthread_attr_getscope(const pthread_attr_t * , int * );
int pthread_attr_getstack(const pthread_attr_t * ,
                                      void ** , size_t * );
int pthread_attr_getstackaddr(const pthread_attr_t * ,
                                      void ** );
int pthread_attr_getstacksize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setdetachstate(pthread_attr_t *,
          int );
int pthread_attr_setguardsize(pthread_attr_t *, size_t );
int pthread_attr_setinheritsched(pthread_attr_t *,
           int );
int pthread_attr_setschedparam(pthread_attr_t * ,
                                     const struct sched_param * );
int pthread_attr_setschedpolicy(pthread_attr_t *,
          int );
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_attr_setstack(pthread_attr_t *,
                                      void *, size_t );
int pthread_attr_setstackaddr(pthread_attr_t *,
                                      void *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t );
int pthread_cancel(pthread_t ) __asm("_" "pthread_cancel" "$UNIX2003");

int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t * ,
                            const pthread_condattr_t * ) __asm("_" "pthread_cond_init" "$UNIX2003");
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t * ,
     pthread_mutex_t * ,
     const struct timespec * ) __asm("_" "pthread_cond_timedwait" "$UNIX2003");
int pthread_cond_wait(pthread_cond_t * ,
       pthread_mutex_t * ) __asm("_" "pthread_cond_wait" "$UNIX2003");
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_getpshared(const pthread_condattr_t * ,
   int * );
int pthread_condattr_setpshared(pthread_condattr_t *,
   int );
int pthread_create(pthread_t * ,
                         const pthread_attr_t * ,
                         void *(*)(void *),
                         void * );
int pthread_detach(pthread_t );
int pthread_equal(pthread_t ,
   pthread_t );
void pthread_exit(void *) __attribute__((__noreturn__));
int pthread_getconcurrency(void);
int pthread_getschedparam(pthread_t , int * , struct sched_param * );
void *pthread_getspecific(pthread_key_t );
int pthread_join(pthread_t , void **) __asm("_" "pthread_join" "$UNIX2003");
int pthread_key_create(pthread_key_t *, void (*)(void *));
int pthread_key_delete(pthread_key_t );
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_getprioceiling(const pthread_mutex_t * , int * );
int pthread_mutex_init(pthread_mutex_t * , const pthread_mutexattr_t * );
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_setprioceiling(pthread_mutex_t * , int, int * );
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" "$UNIX2003");
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_gettype(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int );
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_once(pthread_once_t *, void (*)(void));
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" "$UNIX2003");
int pthread_rwlock_init(pthread_rwlock_t * , const pthread_rwlockattr_t * ) __asm("_" "pthread_rwlock_init" "$UNIX2003");
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" "$UNIX2003");
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" "$UNIX2003");
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" "$UNIX2003");
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" "$UNIX2003");
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" "$UNIX2003");
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
   int * );
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,
   int );
pthread_t pthread_self(void);

int pthread_setcancelstate(int , int *) __asm("_" "pthread_setcancelstate" "$UNIX2003");
int pthread_setcanceltype(int , int *) __asm("_" "pthread_setcanceltype" "$UNIX2003");
int pthread_setconcurrency(int);
int pthread_setschedparam(pthread_t ,
    int ,
                                const struct sched_param *);
int pthread_setspecific(pthread_key_t ,
         const void *);
void pthread_testcancel(void) __asm("_" "pthread_testcancel" "$UNIX2003");



int pthread_is_threaded_np(void);


int pthread_threadid_np(pthread_t,__uint64_t*);



int pthread_getname_np(pthread_t,char*,size_t);
int pthread_setname_np(const char*);

int pthread_main_np(void);


mach_port_t pthread_mach_thread_np(pthread_t);
size_t pthread_get_stacksize_np(pthread_t);
void * pthread_get_stackaddr_np(pthread_t);


int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);


int pthread_cond_timedwait_relative_np(pthread_cond_t *,
     pthread_mutex_t *,
     const struct timespec *);


int pthread_create_suspended_np(pthread_t *,
                         const pthread_attr_t *,
                         void *(*)(void *),
                         void *);
int pthread_kill(pthread_t, int);

pthread_t pthread_from_mach_thread_np(mach_port_t);

int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" "$UNIX2003");
void pthread_yield_np(void);

}
# 44 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr-default.h" 2 3


typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
# 92 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr-default.h" 3
















# 214 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 571 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr-default.h" 3
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return pthread_key_create (key, dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return pthread_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return pthread_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return pthread_setspecific (key, ptr);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (mutex);
  else
    return 0;
}


static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t attr;
      int r;

      r = pthread_mutexattr_init (&attr);
      if (!r)
 r = pthread_mutexattr_settype (&attr, 2);
      if (!r)
 r = pthread_mutex_init (mutex, &attr);
      if (!r)
 r = pthread_mutexattr_destroy (&attr);
      return r;
    }
  return 0;
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_lock (mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_trylock (mutex);
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_unlock (mutex);
}
# 115 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 44 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++io.h" 2 3

namespace std {

  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;

}
# 47 "/usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/usr/include/c++/4.2.1/cctype" 1 3
# 48 "/usr/include/c++/4.2.1/cctype" 3
       
# 49 "/usr/include/c++/4.2.1/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 69 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/runetype.h" 1 3 4
# 70 "/usr/include/runetype.h" 3 4
typedef __darwin_wint_t wint_t;
# 81 "/usr/include/runetype.h" 3 4
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 70 "/usr/include/ctype.h" 2 3 4
# 145 "/usr/include/ctype.h" 3 4
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

static inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 164 "/usr/include/ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


static inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

static inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 204 "/usr/include/ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


static inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






static inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

static inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

static inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

static inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


static inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

static inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

static inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

static inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

static inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

static inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

static inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


static inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

static inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

static inline int
tolower(int _c)
{
        return (__tolower(_c));
}

static inline int
toupper(int _c)
{
        return (__toupper(_c));
}


static inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

static inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

static inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

static inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

static inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

static inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

static inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 52 "/usr/include/c++/4.2.1/cctype" 2 3
# 68 "/usr/include/c++/4.2.1/cctype" 3
namespace std {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 48 "/usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stringfwd.h" 1 3
# 42 "/usr/include/c++/4.2.1/bits/stringfwd.h" 3
       
# 43 "/usr/include/c++/4.2.1/bits/stringfwd.h" 3



namespace std {

  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;


}
# 49 "/usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/usr/include/c++/4.2.1/bits/postypes.h" 1 3
# 44 "/usr/include/c++/4.2.1/bits/postypes.h" 3
       
# 45 "/usr/include/c++/4.2.1/bits/postypes.h" 3

# 1 "/usr/include/c++/4.2.1/cwchar" 1 3
# 48 "/usr/include/c++/4.2.1/cwchar" 3
       
# 49 "/usr/include/c++/4.2.1/cwchar" 3



# 1 "/usr/include/c++/4.2.1/ctime" 1 3
# 48 "/usr/include/c++/4.2.1/ctime" 3
       
# 49 "/usr/include/c++/4.2.1/ctime" 3
# 64 "/usr/include/c++/4.2.1/ctime" 3
namespace std {

  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;

}
# 53 "/usr/include/c++/4.2.1/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef __darwin_mbstate_t mbstate_t;
# 114 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/_wctype.h" 1 3 4
# 52 "/usr/include/_wctype.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 71 "/usr/include/_wctype.h" 3 4
static inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

static inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

static inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

static inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

static inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

static inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

static inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

static inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

static inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

static inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

static inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

static inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

static inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

static inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 176 "/usr/include/_wctype.h" 3 4
extern "C" {
wctype_t
 wctype(const char *);
}
# 115 "/usr/include/wchar.h" 2 3 4

extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...) ;
int fwscanf(FILE * , const wchar_t * , ...) ;
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * ,
     ...) ;
int swscanf(const wchar_t * , const wchar_t * , ...) ;
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list) ;
int vwprintf(const wchar_t * , __darwin_va_list) ;
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" "$UNIX2003");
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...) ;
int wscanf(const wchar_t * , ...) ;


int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list) ;
int vwscanf(const wchar_t * , __darwin_va_list) ;
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** ) ;

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);



size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
     size_t, mbstate_t * );
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
     size_t, mbstate_t * );






}
# 56 "/usr/include/c++/4.2.1/cwchar" 2 3
# 70 "/usr/include/c++/4.2.1/cwchar" 3
namespace std {

  using ::mbstate_t;

}
# 144 "/usr/include/c++/4.2.1/cwchar" 3
namespace std {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }

}







namespace __gnu_cxx {






  using ::wcstold;
# 262 "/usr/include/c++/4.2.1/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 47 "/usr/include/c++/4.2.1/bits/postypes.h" 2 3


# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stdint.h" 1 3 4
# 40 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stdint.h" 3 4
typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long uint64_t;



typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 97 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stdint.h" 3 4
typedef long long int intmax_t;
# 106 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stdint.h" 3 4
typedef long long unsigned int uintmax_t;
# 50 "/usr/include/c++/4.2.1/bits/postypes.h" 2 3


namespace std {
# 72 "/usr/include/c++/4.2.1/bits/postypes.h" 3
  typedef int64_t streamoff;





  typedef ptrdiff_t streamsize;

  template<typename _StateT>
    class fpos;
# 94 "/usr/include/c++/4.2.1/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 116 "/usr/include/c++/4.2.1/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;

}
# 50 "/usr/include/c++/4.2.1/iosfwd" 2 3


namespace std {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 135 "/usr/include/c++/4.2.1/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 71 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_pair.h" 1 3
# 64 "/usr/include/c++/4.2.1/bits/stl_pair.h" 3
namespace std {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 142 "/usr/include/c++/4.2.1/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }

}
# 72 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
# 41 "/usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
       
# 42 "/usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
# 74 "/usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
namespace __gnu_cxx {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std {

namespace __detail
{


  typedef char __one;
  typedef char __two[2];

  template<typename _Tp>
  __one __test_type(int _Tp::*);
  template<typename _Tp>
  __two& __test_type(...);
}


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };


  template<typename _Tp>
    struct __is_pod
    {
      enum
 {
   __value = (sizeof(__detail::__test_type<_Tp>(0))
       != sizeof(__detail::__one))
 };
    };




  template<typename _Tp>
    struct __is_empty
    {
    private:
      template<typename>
        struct __first { };
      template<typename _Up>
        struct __second
        : public _Up { };

    public:
      enum
 {
   __value = sizeof(__first<_Tp>) == sizeof(__second<_Tp>)
 };
    };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


}
# 73 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.2.1/ext/type_traits.h" 1 3
# 38 "/usr/include/c++/4.2.1/ext/type_traits.h" 3
       
# 39 "/usr/include/c++/4.2.1/ext/type_traits.h" 3


# 1 "/usr/include/c++/4.2.1/utility" 1 3
# 63 "/usr/include/c++/4.2.1/utility" 3
       
# 64 "/usr/include/c++/4.2.1/utility" 3


# 1 "/usr/include/c++/4.2.1/bits/stl_relops.h" 1 3
# 74 "/usr/include/c++/4.2.1/bits/stl_relops.h" 3
namespace std {

  namespace rel_ops
  {
# 90 "/usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 103 "/usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 116 "/usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 129 "/usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 67 "/usr/include/c++/4.2.1/utility" 2 3
# 42 "/usr/include/c++/4.2.1/ext/type_traits.h" 2 3


namespace __gnu_cxx {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;

}
# 74 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 1 3
# 67 "/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
       
# 68 "/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3

namespace std {
# 80 "/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};


  struct bidirectional_iterator_tag : public forward_iterator_tag {};


  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 104 "/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 75 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 1 3
# 68 "/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
       
# 69 "/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
# 1 "/usr/include/c++/4.2.1/bits/concept_check.h" 1 3
# 38 "/usr/include/c++/4.2.1/bits/concept_check.h" 3
       
# 39 "/usr/include/c++/4.2.1/bits/concept_check.h" 3
# 70 "/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 2 3

namespace std {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 113 "/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 171 "/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

}
# 76 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 1 3
# 72 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
namespace std {
# 93 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 280 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() - __x.base(); }
# 384 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 410 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }


      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 444 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 459 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 484 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }


      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 518 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 537 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 579 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }


      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 614 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

}

namespace __gnu_cxx {
# 633 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 730 "/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 77 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/4.2.1/debug/debug.h" 1 3
# 47 "/usr/include/c++/4.2.1/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}

namespace __gnu_cxx
{
  namespace __debug { };
}

namespace __gnu_debug
{
  using namespace std::__debug;
  using namespace __gnu_cxx::__debug;
}
# 79 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

namespace std {
# 91 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = *__a;
          *__a = *__b;
          *__b = __tmp;
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 141 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value &&
 __are_same<_ValueType1 &, _ReferenceType1>::__value &&
 __are_same<_ValueType2 &, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 180 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 202 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 224 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 244 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }







  template<bool, typename>
    struct __copy
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy<_BoolType, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };

  template<>
    struct __copy<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<typename _II, typename _OI>
    inline _OI
    __copy_aux(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueTypeI>::__value
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy<__simple, _Category>::copy(__first, __last, __result);
    }


  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT> >::__type
    __copy_aux(_CharT*, _CharT*, ostreambuf_iterator<_CharT>);

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_aux(const _CharT*, const _CharT*, ostreambuf_iterator<_CharT>);

  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT*>::__type
    __copy_aux(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
        _CharT*);

  template<bool, bool>
    struct __copy_normal
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_normal<true, false>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first.base(), __last.base(), __result); }
    };

  template<>
    struct __copy_normal<false, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first, __last, __result.base())); }
    };

  template<>
    struct __copy_normal<true, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first.base(), __last.base(),
         __result.base())); }
    };
# 387 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

      ;

       const bool __in = __is_normal_iterator<_InputIterator>::__value;
       const bool __out = __is_normal_iterator<_OutputIterator>::__value;
       return std::__copy_normal<__in, __out>::__copy_n(__first, __last,
       __result);
    }


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                 ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
  ostreambuf_iterator<_CharT>);

  template<bool, typename>
    struct __copy_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy_backward<_BoolType, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };

  template<>
    struct __copy_backward<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueType1>::__value
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_backward<__simple, _Category>::__copy_b(__first,
         __last,
         __result);
    }

  template<bool, bool>
    struct __copy_backward_normal
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_backward_normal<true, false>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first.base(), __last.base(),
       __result); }
    };

  template<>
    struct __copy_backward_normal<false, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first, __last,
            __result.base())); }
    };

  template<>
    struct __copy_backward_normal<true, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first.base(), __last.base(),
            __result.base())); }
    };
# 524 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      const bool __bi1 = __is_normal_iterator<_BI1>::__value;
      const bool __bi2 = __is_normal_iterator<_BI2>::__value;
      return std::__copy_backward_normal<__bi1, __bi2>::__copy_b_n(__first,
           __last,
           __result);
    }

  template<bool>
    struct __fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   for (; __first != __last; ++__first)
     *__first = __value;
 }
    };

  template<>
    struct __fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __first != __last; ++__first)
     *__first = __tmp;
 }
    };
# 581 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      const bool __scalar = __is_scalar<_Tp>::__value;
      std::__fill<__scalar>::fill(__first, __last, __value);
    }


  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
    ;
    const unsigned char __tmp = __c;
    std::memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
    ;
    const signed char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
    ;
    const char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<bool>
    struct __fill_n
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   for (; __n > 0; --__n, ++__first)
     *__first = __value;
   return __first;
 }
    };

  template<>
    struct __fill_n<true>
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __n > 0; --__n, ++__first)
     *__first = __tmp;
   return __first;
 }
    };
# 657 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _OutputIterator, typename _Size, typename _Tp>
    _OutputIterator
    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
    {

     

      const bool __scalar = __is_scalar<_Tp>::__value;
      return std::__fill_n<__scalar>::fill_n(__first, __n, __value);
    }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(signed char* __first, _Size __n, const signed char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 704 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 739 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 769 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return true;
    }
# 801 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2,
   _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
   return false;
      return true;
    }
# 833 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (*__first1 < *__first2)
     return true;
   if (*__first2 < *__first1)
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 873 "/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _Compare __comp)
    {

     
     
      ;
      ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
    ;
    ;

    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2,
         std::min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {
    ;
    ;


    return std::lexicographical_compare((const signed char*) __first1,
     (const signed char*) __last1,
     (const signed char*) __first2,
     (const signed char*) __last2);






  }

}
# 67 "/usr/include/c++/4.2.1/vector" 2 3
# 1 "/usr/include/c++/4.2.1/bits/allocator.h" 1 3
# 53 "/usr/include/c++/4.2.1/bits/allocator.h" 3
# 1 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++allocator.h" 1 3
# 39 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.2.1/ext/new_allocator.h" 1 3
# 37 "/usr/include/c++/4.2.1/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.2.1/new" 1 3
# 45 "/usr/include/c++/4.2.1/new" 3
# 1 "/usr/include/c++/4.2.1/exception" 1 3
# 40 "/usr/include/c++/4.2.1/exception" 3
#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 56 "/usr/include/c++/4.2.1/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 112 "/usr/include/c++/4.2.1/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx {
# 127 "/usr/include/c++/4.2.1/exception" 3
  void __verbose_terminate_handler ();

}

}

#pragma GCC visibility pop
# 46 "/usr/include/c++/4.2.1/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 95 "/usr/include/c++/4.2.1/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 38 "/usr/include/c++/4.2.1/ext/new_allocator.h" 2 3


namespace __gnu_cxx {

  using std::size_t;
  using std::ptrdiff_t;
# 52 "/usr/include/c++/4.2.1/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new(__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 40 "/usr/include/c++/4.2.1/i686-apple-darwin10/bits/c++allocator.h" 2 3
# 54 "/usr/include/c++/4.2.1/bits/allocator.h" 2 3



namespace std {

  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };







  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = std::__is_empty<_Alloc>::__value>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };

}
# 68 "/usr/include/c++/4.2.1/vector" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_construct.h" 1 3
# 67 "/usr/include/c++/4.2.1/bits/stl_construct.h" 3
namespace std {







  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }







  template<typename _T1>
    inline void
    _Construct(_T1* __p)
    {


      ::new(static_cast<void*>(__p)) _T1();
    }






  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 116 "/usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
    __false_type)
    {
      for (; __first != __last; ++__first)
 std::_Destroy(&*__first);
    }
# 134 "/usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }
# 146 "/usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename std::__is_scalar<_Value_type>::__type
                _Has_trivial_destructor;

      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
    }
# 166 "/usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>)
    {
      _Destroy(__first, __last);
    }

}
# 69 "/usr/include/c++/4.2.1/vector" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 1 3
# 67 "/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
namespace std {


  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __true_type)
    { return std::copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __false_type)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }
# 106 "/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      return std::__uninitialized_copy_aux(__first, __last, __result,
        _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    std::memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
       wchar_t* __result)
  {
    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __x, __true_type)
    { std::fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 168 "/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __true_type)
    { std::fill_n(__first, __n, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 213 "/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      _Allocator __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      allocator<_Tp>)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        allocator<_Tp2>)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 318 "/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last,
         _Allocator __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_copy_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }

}
# 70 "/usr/include/c++/4.2.1/vector" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_vector.h" 1 3
# 69 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
namespace std {






  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 _Tp* _M_start;
 _Tp* _M_finish;
 _Tp* _M_end_of_storage;
 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a)
      { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
   if (__n)
   {
     this->_M_impl._M_start = this->_M_allocate(__n);
     this->_M_impl._M_finish = this->_M_impl._M_start;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   }
      }

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      _Tp*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(__n); }

      void
      _M_deallocate(_Tp* __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 161 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      explicit
      vector(const allocator_type& __a = allocator_type())
      : _Base(__a)
      { }
# 212 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_start + __n;
      }
# 231 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 254 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 282 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 295 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 311 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }



      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 418 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }





      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 461 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 476 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 491 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 516 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 534 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 580 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }

      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
# 599 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 620 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 638 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 654 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 672 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 697 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 718 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 730 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:






      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }





      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }






      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      void
      _M_insert_aux(iterator __position, const value_type& __x);





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 940 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 957 "/usr/include/c++/4.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

}
# 71 "/usr/include/c++/4.2.1/vector" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_bvector.h" 1 3
# 65 "/usr/include/c++/4.2.1/bits/stl_bvector.h" 3
namespace std {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<class _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;
 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }

      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };

}




namespace std {
# 455 "/usr/include/c++/4.2.1/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;

  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    explicit
    vector(const allocator_type& __a = allocator_type())
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    template<class _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }





    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<class _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }

    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }

    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= size_type(-1) / int(_S_word_bit) ?
       __asize * int(_S_word_bit) : size_type(-1));
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector<bool, _Alloc>& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<class _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }

    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }

    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }


    template<class _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(__n);
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<class _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<class _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<class _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }

    template<class _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign((size_t) __n, (bool) __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<class _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<class _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }


    template<class _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<class _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len = size() + std::max(size(), __n);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    template<class _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<class _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len = size() + std::max(size(), __n);
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

    void
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len = size() ? 2 * size()
                                  : static_cast<size_type>(_S_word_bit);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };

}
# 72 "/usr/include/c++/4.2.1/vector" 2 3


# 1 "/usr/include/c++/4.2.1/bits/vector.tcc" 1 3
# 64 "/usr/include/c++/4.2.1/bits/vector.tcc" 3
namespace std {

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n, this->_M_impl._M_start,
            this->_M_impl._M_finish);
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
        _M_insert_aux(__position, __x);
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::copy(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      *(this->_M_impl._M_finish - 1));
   ++this->_M_impl._M_finish;
   _Tp __x_copy = __x;
   std::copy_backward(__position.base(),
        this->_M_impl._M_finish - 2,
        this->_M_impl._M_finish - 1);
   *__position = __x_copy;
 }
      else
 {
   const size_type __old_size = size();
   if (__old_size == this->max_size())
     __throw_length_error(("vector::_M_insert_aux"));




   size_type __len = __old_size != 0 ? 2 * __old_size : 1;
   if (__len < __old_size)
     __len = this->max_size();

   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {
       __new_finish =
  std::__uninitialized_copy_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       this->_M_impl.construct(__new_finish, __x);
       ++__new_finish;
       __new_finish =
  std::__uninitialized_copy_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
   catch(...)
     {
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n,
         __old_finish);
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_copy_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __old_size = size();
       if (this->max_size() - __old_size < __n)
  __throw_length_error(("vector::_M_fill_insert"));


       size_type __len = __old_size + std::max(__old_size, __n);
       if (__len < __old_size)
  __len = this->max_size();

       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish =
      std::__uninitialized_copy_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    std::__uninitialized_fill_n_a(__new_finish, __n, __x,
      _M_get_Tp_allocator());
    __new_finish += __n;
    __new_finish =
      std::__uninitialized_copy_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp, _Alloc>::
    _M_range_insert(iterator __pos, _InputIterator __first,
      _InputIterator __last, std::input_iterator_tag)
    {
      for (; __first != __last; ++__first)
 {
   __pos = insert(__pos, *__first);
   ++__pos;
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n,
           __old_finish);
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_copy_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __old_size = size();
  if (this->max_size() - __old_size < __n)
    __throw_length_error(("vector::_M_range_insert"));


  size_type __len = __old_size + std::max(__old_size, __n);
  if (__len < __old_size)
    __len = this->max_size();

  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_copy_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last, __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }

}
# 75 "/usr/include/c++/4.2.1/vector" 2 3
# 5 "../../src/core/gxRect.h" 2

class gxRect;

typedef std::vector< gxRect > gxRects;
typedef gxRects::iterator gxRectsIterator;

# 1 "../../src/adapters/wx/gxRect.h" 1



# 1 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h" 1
# 19 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/defs.h" 1
# 21 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/platform.h" 1
# 36 "/Development/gefri/build/../libs/wx/include/wx/platform.h"
# 1 "/usr/include/AvailabilityMacros.h" 1 3 4
# 37 "/Development/gefri/build/../libs/wx/include/wx/platform.h" 2
# 196 "/Development/gefri/build/../libs/wx/include/wx/platform.h"
# 1 "/Development/gefri/build/../libs/wx/build/mac/32/debug/wx/include/mac-unicode-debug-static-2.8/wx/setup.h" 1
# 197 "/Development/gefri/build/../libs/wx/include/wx/platform.h" 2
# 293 "/Development/gefri/build/../libs/wx/include/wx/platform.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/chkconf.h" 1
# 25 "/Development/gefri/build/../libs/wx/include/wx/chkconf.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/mac/chkconf.h" 1
# 33 "/Development/gefri/build/../libs/wx/include/wx/mac/chkconf.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/mac/carbon/chkconf.h" 1
# 34 "/Development/gefri/build/../libs/wx/include/wx/mac/chkconf.h" 2
# 26 "/Development/gefri/build/../libs/wx/include/wx/chkconf.h" 2
# 294 "/Development/gefri/build/../libs/wx/include/wx/platform.h" 2
# 22 "/Development/gefri/build/../libs/wx/include/wx/defs.h" 2
# 63 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/features.h" 1
# 64 "/Development/gefri/build/../libs/wx/include/wx/defs.h" 2
# 134 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/version.h" 1
# 17 "/Development/gefri/build/../libs/wx/include/wx/version.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/cpp.h" 1
# 18 "/Development/gefri/build/../libs/wx/include/wx/version.h" 2
# 135 "/Development/gefri/build/../libs/wx/include/wx/defs.h" 2
# 237 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef short int WXTYPE;






typedef int wxWindowID;
# 490 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/dlimpexp.h" 1
# 491 "/Development/gefri/build/../libs/wx/include/wx/defs.h" 2
# 521 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/debug.h" 1
# 18 "/Development/gefri/build/../libs/wx/include/wx/debug.h"
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 19 "/Development/gefri/build/../libs/wx/include/wx/debug.h" 2

# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/limits.h" 1 3 4






# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/syslimits.h" 1 3 4
# 8 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/limits.h" 2 3 4
# 21 "/Development/gefri/build/../libs/wx/include/wx/debug.h" 2

# 1 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h" 1
# 212 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
        typedef wchar_t wxChar;
        typedef wchar_t wxSChar;
        typedef wchar_t wxUChar;
# 541 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
# 1 "/usr/include/wctype.h" 1 3 4
# 39 "/usr/include/wctype.h" 3 4
typedef __darwin_wctrans_t wctrans_t;
# 62 "/usr/include/wctype.h" 3 4
static inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


static inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

static inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

static inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

static inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

static inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

static inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

static inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 130 "/usr/include/wctype.h" 3 4
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 542 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h" 2
# 617 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
                int wxPutc(wxChar ch, FILE *stream);
# 630 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
                int wxPuts(const wxChar *ws);
# 862 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
inline bool wxIsEmpty(const wxChar *p) { return !p || !*p; }


inline size_t wxStrlen(const wxChar *psz) { return psz ? wcslen(psz) : 0; }
# 882 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
 bool wxOKlibc();
# 1019 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
    int
    wxSnprintf_(wxChar *buf, size_t len, const wxChar *format, ...) ;
# 1060 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
    int wxScanf( const wxChar *format, ... ) ;
    int wxSscanf( const wxChar *str, const wxChar *format, ... ) ;
    int wxFscanf( FILE *stream, const wxChar *format, ... ) ;
    int wxVsscanf( const wxChar *str, const wxChar *format, va_list ap );
    int wxPrintf( const wxChar *format, ... ) ;
    int wxSprintf( wxChar *str, const wxChar *format, ... ) ;
    int wxFprintf( FILE *stream, const wxChar *format, ... ) ;
    int wxVfprintf( FILE *stream, const wxChar *format, va_list ap );
    int wxVprintf( const wxChar *format, va_list ap );
    int wxVsprintf( wxChar *str, const wxChar *format, va_list ap );
# 1079 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
    int wxSnprintf( wxChar *str, size_t size, const wxChar *format, ... ) ;
    int wxVsnprintf( wxChar *str, size_t size, const wxChar *format, va_list ap );
# 1214 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
 wchar_t *wxStrdupW(const wchar_t *pwz);



 int wxStricmp(const wxChar *psz1, const wxChar *psz2);



 int wxStrnicmp(const wxChar *psz1, const wxChar *psz2, size_t len);



 wxChar * wxStrtok(wxChar *psz, const wxChar *delim, wxChar **save_ptr);




class wxWCharBuffer;
 wxWCharBuffer wxSetlocale(int category, const wxChar *locale);






    FILE * wxFopen(const wxChar *path, const wxChar *mode);
    FILE * wxFreopen(const wxChar *path, const wxChar *mode, FILE *stream);
    int wxRemove(const wxChar *path);
    int wxRename(const wxChar *oldpath, const wxChar *newpath);







 double wxAtof(const wxChar *psz);
# 1262 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
 int wxAtoi(const wxChar *psz);
 long wxAtol(const wxChar *psz);
 wxChar * wxGetenv(const wxChar *name);




 int wxSystem(const wxChar *psz);
# 1279 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
    struct tm;
    size_t wxStrftime(wxChar *s, size_t max,
                                  const wxChar *fmt, const struct tm *tm);




 wxChar *wxCtime(const time_t *timep);
# 1301 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
    size_t wxMB2WC(wchar_t *buf, const char *psz, size_t n);
    size_t wxWC2MB(char *buf, const wchar_t *psz, size_t n);
# 1346 "/Development/gefri/build/../libs/wx/include/wx/wxchar.h"
        inline wxChar* wxTmemchr(const wxChar* s, wxChar c, size_t l)
        {
            for(;l && *s != c;--l, ++s) {}

            if(l)
                return (wxChar*)s;
            return __null;
        }

        inline int wxTmemcmp(const wxChar* sz1, const wxChar* sz2, size_t len)
        {
            for(; *sz1 == *sz2 && len; --len, ++sz1, ++sz2) {}

            if(len)
                return *sz1 < *sz2 ? -1 : *sz1 > *sz2;
            else
                return 0;
        }

        inline wxChar* wxTmemcpy(wxChar* szOut, const wxChar* szIn, size_t len)
        {
            return (wxChar*) memcpy(szOut, szIn, len * sizeof(wxChar));
        }

        inline wxChar* wxTmemmove(wxChar* szOut, const wxChar* szIn, size_t len)
        {
            return (wxChar*) memmove(szOut, szIn, len * sizeof(wxChar));
        }

        inline wxChar* wxTmemset(wxChar* szOut, const wxChar cIn, size_t len)
        {
            wxChar* szRet = szOut;

            while (len--)
                *szOut++ = cIn;

            return szRet;
        }
# 23 "/Development/gefri/build/../libs/wx/include/wx/debug.h" 2
# 103 "/Development/gefri/build/../libs/wx/include/wx/debug.h"
  extern void wxOnAssert(const wxChar *szFile,
                                          int nLine,
                                          const char *szFunc,
                                          const wxChar *szCond,
                                          const wxChar *szMsg = __null);



  extern void wxTrap();
# 152 "/Development/gefri/build/../libs/wx/include/wx/debug.h"
  extern bool wxAssertIsEqual(int x, int y);
# 168 "/Development/gefri/build/../libs/wx/include/wx/debug.h"
    extern const bool wxFalse;
# 310 "/Development/gefri/build/../libs/wx/include/wx/debug.h"
        extern bool wxIsDebuggerRunning();
# 522 "/Development/gefri/build/../libs/wx/include/wx/defs.h" 2





# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stddef.h" 1 3 4
# 528 "/Development/gefri/build/../libs/wx/include/wx/defs.h" 2
# 602 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
        template <class T>
            inline void wxUnusedVar(const T& ) { }
# 651 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef int wxCoord;

enum { wxDefaultCoord = -1 };
# 670 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef signed char wxInt8;
typedef unsigned char wxUint8;
typedef wxUint8 wxByte;
# 684 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef signed short wxInt16;
typedef unsigned short wxUint16;

typedef wxUint16 wxWord;
# 781 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
            typedef int wxInt32;
            typedef unsigned int wxUint32;
# 824 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef wxUint32 wxDword;






    typedef unsigned long wxUIntPtr;
    typedef long wxIntPtr;
# 847 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
inline wxUIntPtr wxPtrToUInt(const void *p)
{
# 866 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
    return reinterpret_cast<wxUIntPtr>(p);




}

inline void *wxUIntToPtr(wxUIntPtr p)
{
# 887 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
    return reinterpret_cast<void *>(p);




}
# 980 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
    typedef long long wxInt64;
    typedef unsigned long long wxUint64;
# 1036 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef float wxFloat32;



    typedef double wxFloat64;


typedef double wxDouble;
# 1215 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
enum wxGeometryCentre
{
    wxCENTRE = 0x0001,
    wxCENTER = wxCENTRE
};







enum wxOrientation
{

    wxHORIZONTAL = 0x0004,
    wxVERTICAL = 0x0008,

    wxBOTH = wxVERTICAL | wxHORIZONTAL
};

enum wxDirection
{
    wxLEFT = 0x0010,
    wxRIGHT = 0x0020,
    wxUP = 0x0040,
    wxDOWN = 0x0080,

    wxTOP = wxUP,
    wxBOTTOM = wxDOWN,

    wxNORTH = wxUP,
    wxSOUTH = wxDOWN,
    wxWEST = wxLEFT,
    wxEAST = wxRIGHT,

    wxALL = (wxUP | wxDOWN | wxRIGHT | wxLEFT)
};

enum wxAlignment
{
    wxALIGN_NOT = 0x0000,
    wxALIGN_CENTER_HORIZONTAL = 0x0100,
    wxALIGN_CENTRE_HORIZONTAL = wxALIGN_CENTER_HORIZONTAL,
    wxALIGN_LEFT = wxALIGN_NOT,
    wxALIGN_TOP = wxALIGN_NOT,
    wxALIGN_RIGHT = 0x0200,
    wxALIGN_BOTTOM = 0x0400,
    wxALIGN_CENTER_VERTICAL = 0x0800,
    wxALIGN_CENTRE_VERTICAL = wxALIGN_CENTER_VERTICAL,

    wxALIGN_CENTER = (wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL),
    wxALIGN_CENTRE = wxALIGN_CENTER,


    wxALIGN_MASK = 0x0f00
};

enum wxStretch
{
    wxSTRETCH_NOT = 0x0000,
    wxSHRINK = 0x1000,
    wxGROW = 0x2000,
    wxEXPAND = wxGROW,
    wxSHAPED = 0x4000,
    wxFIXED_MINSIZE = 0x8000,

    wxRESERVE_SPACE_EVEN_IF_HIDDEN = 0x0002,

    wxTILE = 0xc000,





    wxADJUST_MINSIZE = 0

};


enum wxBorder
{


    wxBORDER_DEFAULT = 0,

    wxBORDER_NONE = 0x00200000,
    wxBORDER_STATIC = 0x01000000,
    wxBORDER_SIMPLE = 0x02000000,
    wxBORDER_RAISED = 0x04000000,
    wxBORDER_SUNKEN = 0x08000000,
    wxBORDER_DOUBLE = 0x10000000,
    wxBORDER_THEME = 0x10000000,


    wxBORDER_MASK = 0x1f200000
};
# 1629 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
enum wxBackgroundStyle
{
  wxBG_STYLE_SYSTEM,
  wxBG_STYLE_COLOUR,
  wxBG_STYLE_CUSTOM
};






enum
{

    wxID_NONE = -3,


    wxID_SEPARATOR = -2,



    wxID_ANY = -1,



    wxID_LOWEST = 4999,

    wxID_OPEN,
    wxID_CLOSE,
    wxID_NEW,
    wxID_SAVE,
    wxID_SAVEAS,
    wxID_REVERT,
    wxID_EXIT,
    wxID_UNDO,
    wxID_REDO,
    wxID_HELP,
    wxID_PRINT,
    wxID_PRINT_SETUP,
    wxID_PAGE_SETUP,
    wxID_PREVIEW,
    wxID_ABOUT,
    wxID_HELP_CONTENTS,
    wxID_HELP_INDEX,
    wxID_HELP_SEARCH,
    wxID_HELP_COMMANDS,
    wxID_HELP_PROCEDURES,
    wxID_HELP_CONTEXT,
    wxID_CLOSE_ALL,
    wxID_PREFERENCES,

    wxID_EDIT = 5030,
    wxID_CUT,
    wxID_COPY,
    wxID_PASTE,
    wxID_CLEAR,
    wxID_FIND,
    wxID_DUPLICATE,
    wxID_SELECTALL,
    wxID_DELETE,
    wxID_REPLACE,
    wxID_REPLACE_ALL,
    wxID_PROPERTIES,

    wxID_VIEW_DETAILS,
    wxID_VIEW_LARGEICONS,
    wxID_VIEW_SMALLICONS,
    wxID_VIEW_LIST,
    wxID_VIEW_SORTDATE,
    wxID_VIEW_SORTNAME,
    wxID_VIEW_SORTSIZE,
    wxID_VIEW_SORTTYPE,

    wxID_FILE = 5050,
    wxID_FILE1,
    wxID_FILE2,
    wxID_FILE3,
    wxID_FILE4,
    wxID_FILE5,
    wxID_FILE6,
    wxID_FILE7,
    wxID_FILE8,
    wxID_FILE9,


    wxID_OK = 5100,
    wxID_CANCEL,
    wxID_APPLY,
    wxID_YES,
    wxID_NO,
    wxID_STATIC,
    wxID_FORWARD,
    wxID_BACKWARD,
    wxID_DEFAULT,
    wxID_MORE,
    wxID_SETUP,
    wxID_RESET,
    wxID_CONTEXT_HELP,
    wxID_YESTOALL,
    wxID_NOTOALL,
    wxID_ABORT,
    wxID_RETRY,
    wxID_IGNORE,
    wxID_ADD,
    wxID_REMOVE,

    wxID_UP,
    wxID_DOWN,
    wxID_HOME,
    wxID_REFRESH,
    wxID_STOP,
    wxID_INDEX,

    wxID_BOLD,
    wxID_ITALIC,
    wxID_JUSTIFY_CENTER,
    wxID_JUSTIFY_FILL,
    wxID_JUSTIFY_RIGHT,
    wxID_JUSTIFY_LEFT,
    wxID_UNDERLINE,
    wxID_INDENT,
    wxID_UNINDENT,
    wxID_ZOOM_100,
    wxID_ZOOM_FIT,
    wxID_ZOOM_IN,
    wxID_ZOOM_OUT,
    wxID_UNDELETE,
    wxID_REVERT_TO_SAVED,


    wxID_SYSTEM_MENU = 5200,
    wxID_CLOSE_FRAME,
    wxID_MOVE_FRAME,
    wxID_RESIZE_FRAME,
    wxID_MAXIMIZE_FRAME,
    wxID_ICONIZE_FRAME,
    wxID_RESTORE_FRAME,


    wxID_FILEDLGG = 5900,

    wxID_HIGHEST = 5999
};






enum wxItemKind
{
    wxITEM_SEPARATOR = -1,
    wxITEM_NORMAL,
    wxITEM_CHECK,
    wxITEM_RADIO,
    wxITEM_MAX
};


enum wxHitTest
{
    wxHT_NOWHERE,


    wxHT_SCROLLBAR_FIRST = wxHT_NOWHERE,
    wxHT_SCROLLBAR_ARROW_LINE_1,
    wxHT_SCROLLBAR_ARROW_LINE_2,
    wxHT_SCROLLBAR_ARROW_PAGE_1,
    wxHT_SCROLLBAR_ARROW_PAGE_2,
    wxHT_SCROLLBAR_THUMB,
    wxHT_SCROLLBAR_BAR_1,
    wxHT_SCROLLBAR_BAR_2,
    wxHT_SCROLLBAR_LAST,


    wxHT_WINDOW_OUTSIDE,
    wxHT_WINDOW_INSIDE,
    wxHT_WINDOW_VERT_SCROLLBAR,
    wxHT_WINDOW_HORZ_SCROLLBAR,
    wxHT_WINDOW_CORNER,

    wxHT_MAX
};
# 1838 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
enum
{

    wxDEFAULT = 70,
    wxDECORATIVE,
    wxROMAN,
    wxSCRIPT,
    wxSWISS,
    wxMODERN,
    wxTELETYPE,


    wxVARIABLE = 80,
    wxFIXED,

    wxNORMAL = 90,
    wxLIGHT,
    wxBOLD,

    wxITALIC,
    wxSLANT,


    wxSOLID = 100,
    wxDOT,
    wxLONG_DASH,
    wxSHORT_DASH,
    wxDOT_DASH,
    wxUSER_DASH,

    wxTRANSPARENT,



    wxSTIPPLE_MASK_OPAQUE,
    wxSTIPPLE_MASK,

    wxSTIPPLE = 110,

    wxBDIAGONAL_HATCH,
    wxCROSSDIAG_HATCH,
    wxFDIAGONAL_HATCH,
    wxCROSS_HATCH,
    wxHORIZONTAL_HATCH,
    wxVERTICAL_HATCH,
    wxFIRST_HATCH = wxBDIAGONAL_HATCH,
    wxLAST_HATCH = wxVERTICAL_HATCH,

    wxJOIN_BEVEL = 120,
    wxJOIN_MITER,
    wxJOIN_ROUND,

    wxCAP_ROUND = 130,
    wxCAP_PROJECTING,
    wxCAP_BUTT
};
# 1902 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef enum
{
    wxCLEAR, wxROP_BLACK = wxCLEAR, wxBLIT_BLACKNESS = wxCLEAR,
    wxXOR, wxROP_XORPEN = wxXOR, wxBLIT_SRCINVERT = wxXOR,
    wxINVERT, wxROP_NOT = wxINVERT, wxBLIT_DSTINVERT = wxINVERT,
    wxOR_REVERSE, wxROP_MERGEPENNOT = wxOR_REVERSE, wxBLIT_00DD0228 = wxOR_REVERSE,
    wxAND_REVERSE, wxROP_MASKPENNOT = wxAND_REVERSE, wxBLIT_SRCERASE = wxAND_REVERSE,
    wxCOPY, wxROP_COPYPEN = wxCOPY, wxBLIT_SRCCOPY = wxCOPY,
    wxAND, wxROP_MASKPEN = wxAND, wxBLIT_SRCAND = wxAND,
    wxAND_INVERT, wxROP_MASKNOTPEN = wxAND_INVERT, wxBLIT_00220326 = wxAND_INVERT,
    wxNO_OP, wxROP_NOP = wxNO_OP, wxBLIT_00AA0029 = wxNO_OP,
    wxNOR, wxROP_NOTMERGEPEN = wxNOR, wxBLIT_NOTSRCERASE = wxNOR,
    wxEQUIV, wxROP_NOTXORPEN = wxEQUIV, wxBLIT_00990066 = wxEQUIV,
    wxSRC_INVERT, wxROP_NOTCOPYPEN = wxSRC_INVERT, wxBLIT_NOTSCRCOPY = wxSRC_INVERT,
    wxOR_INVERT, wxROP_MERGENOTPEN = wxOR_INVERT, wxBLIT_MERGEPAINT = wxOR_INVERT,
    wxNAND, wxROP_NOTMASKPEN = wxNAND, wxBLIT_007700E6 = wxNAND,
    wxOR, wxROP_MERGEPEN = wxOR, wxBLIT_SRCPAINT = wxOR,
    wxSET, wxROP_WHITE = wxSET, wxBLIT_WHITENESS = wxSET
} form_ops_t;


enum
{
    wxFLOOD_SURFACE = 1,
    wxFLOOD_BORDER
};


enum
{
    wxODDEVEN_RULE = 1,
    wxWINDING_RULE
};


enum
{
    wxTOOL_TOP = 1,
    wxTOOL_BOTTOM,
    wxTOOL_LEFT,
    wxTOOL_RIGHT
};



enum wxDataFormatId
{
    wxDF_INVALID = 0,
    wxDF_TEXT = 1,
    wxDF_BITMAP = 2,
    wxDF_METAFILE = 3,
    wxDF_SYLK = 4,
    wxDF_DIF = 5,
    wxDF_TIFF = 6,
    wxDF_OEMTEXT = 7,
    wxDF_DIB = 8,
    wxDF_PALETTE = 9,
    wxDF_PENDATA = 10,
    wxDF_RIFF = 11,
    wxDF_WAVE = 12,
    wxDF_UNICODETEXT = 13,
    wxDF_ENHMETAFILE = 14,
    wxDF_FILENAME = 15,
    wxDF_LOCALE = 16,
    wxDF_PRIVATE = 20,
    wxDF_HTML = 30,
    wxDF_MAX
};


enum wxKeyCode
{
    WXK_BACK = 8,
    WXK_TAB = 9,
    WXK_RETURN = 13,
    WXK_ESCAPE = 27,
    WXK_SPACE = 32,
    WXK_DELETE = 127,




    WXK_START = 300,
    WXK_LBUTTON,
    WXK_RBUTTON,
    WXK_CANCEL,
    WXK_MBUTTON,
    WXK_CLEAR,
    WXK_SHIFT,
    WXK_ALT,
    WXK_CONTROL,
    WXK_MENU,
    WXK_PAUSE,
    WXK_CAPITAL,
    WXK_END,
    WXK_HOME,
    WXK_LEFT,
    WXK_UP,
    WXK_RIGHT,
    WXK_DOWN,
    WXK_SELECT,
    WXK_PRINT,
    WXK_EXECUTE,
    WXK_SNAPSHOT,
    WXK_INSERT,
    WXK_HELP,
    WXK_NUMPAD0,
    WXK_NUMPAD1,
    WXK_NUMPAD2,
    WXK_NUMPAD3,
    WXK_NUMPAD4,
    WXK_NUMPAD5,
    WXK_NUMPAD6,
    WXK_NUMPAD7,
    WXK_NUMPAD8,
    WXK_NUMPAD9,
    WXK_MULTIPLY,
    WXK_ADD,
    WXK_SEPARATOR,
    WXK_SUBTRACT,
    WXK_DECIMAL,
    WXK_DIVIDE,
    WXK_F1,
    WXK_F2,
    WXK_F3,
    WXK_F4,
    WXK_F5,
    WXK_F6,
    WXK_F7,
    WXK_F8,
    WXK_F9,
    WXK_F10,
    WXK_F11,
    WXK_F12,
    WXK_F13,
    WXK_F14,
    WXK_F15,
    WXK_F16,
    WXK_F17,
    WXK_F18,
    WXK_F19,
    WXK_F20,
    WXK_F21,
    WXK_F22,
    WXK_F23,
    WXK_F24,
    WXK_NUMLOCK,
    WXK_SCROLL,
    WXK_PAGEUP,
    WXK_PAGEDOWN,

    WXK_PRIOR = WXK_PAGEUP,
    WXK_NEXT = WXK_PAGEDOWN,


    WXK_NUMPAD_SPACE,
    WXK_NUMPAD_TAB,
    WXK_NUMPAD_ENTER,
    WXK_NUMPAD_F1,
    WXK_NUMPAD_F2,
    WXK_NUMPAD_F3,
    WXK_NUMPAD_F4,
    WXK_NUMPAD_HOME,
    WXK_NUMPAD_LEFT,
    WXK_NUMPAD_UP,
    WXK_NUMPAD_RIGHT,
    WXK_NUMPAD_DOWN,
    WXK_NUMPAD_PAGEUP,
    WXK_NUMPAD_PAGEDOWN,

    WXK_NUMPAD_PRIOR = WXK_NUMPAD_PAGEUP,
    WXK_NUMPAD_NEXT = WXK_NUMPAD_PAGEDOWN,

    WXK_NUMPAD_END,
    WXK_NUMPAD_BEGIN,
    WXK_NUMPAD_INSERT,
    WXK_NUMPAD_DELETE,
    WXK_NUMPAD_EQUAL,
    WXK_NUMPAD_MULTIPLY,
    WXK_NUMPAD_ADD,
    WXK_NUMPAD_SEPARATOR,
    WXK_NUMPAD_SUBTRACT,
    WXK_NUMPAD_DECIMAL,
    WXK_NUMPAD_DIVIDE,

    WXK_WINDOWS_LEFT,
    WXK_WINDOWS_RIGHT,
    WXK_WINDOWS_MENU ,
    WXK_COMMAND,


    WXK_SPECIAL1 = 193,
    WXK_SPECIAL2,
    WXK_SPECIAL3,
    WXK_SPECIAL4,
    WXK_SPECIAL5,
    WXK_SPECIAL6,
    WXK_SPECIAL7,
    WXK_SPECIAL8,
    WXK_SPECIAL9,
    WXK_SPECIAL10,
    WXK_SPECIAL11,
    WXK_SPECIAL12,
    WXK_SPECIAL13,
    WXK_SPECIAL14,
    WXK_SPECIAL15,
    WXK_SPECIAL16,
    WXK_SPECIAL17,
    WXK_SPECIAL18,
    WXK_SPECIAL19,
    WXK_SPECIAL20
};


enum wxKeyModifier
{
    wxMOD_NONE = 0x0000,
    wxMOD_ALT = 0x0001,
    wxMOD_CONTROL = 0x0002,
    wxMOD_ALTGR = wxMOD_ALT | wxMOD_CONTROL,
    wxMOD_SHIFT = 0x0004,
    wxMOD_META = 0x0008,
    wxMOD_WIN = wxMOD_META,

    wxMOD_CMD = wxMOD_META,



    wxMOD_ALL = 0xffff
};


enum
{
    wxMM_TEXT = 1,
    wxMM_LOMETRIC,
    wxMM_HIMETRIC,
    wxMM_LOENGLISH,
    wxMM_HIENGLISH,
    wxMM_TWIPS,
    wxMM_ISOTROPIC,
    wxMM_ANISOTROPIC,
    wxMM_POINTS,
    wxMM_METRIC
};





typedef enum
{
    wxPAPER_NONE,
    wxPAPER_LETTER,
    wxPAPER_LEGAL,
    wxPAPER_A4,
    wxPAPER_CSHEET,
    wxPAPER_DSHEET,
    wxPAPER_ESHEET,
    wxPAPER_LETTERSMALL,
    wxPAPER_TABLOID,
    wxPAPER_LEDGER,
    wxPAPER_STATEMENT,
    wxPAPER_EXECUTIVE,
    wxPAPER_A3,
    wxPAPER_A4SMALL,
    wxPAPER_A5,
    wxPAPER_B4,
    wxPAPER_B5,
    wxPAPER_FOLIO,
    wxPAPER_QUARTO,
    wxPAPER_10X14,
    wxPAPER_11X17,
    wxPAPER_NOTE,
    wxPAPER_ENV_9,
    wxPAPER_ENV_10,
    wxPAPER_ENV_11,
    wxPAPER_ENV_12,
    wxPAPER_ENV_14,
    wxPAPER_ENV_DL,
    wxPAPER_ENV_C5,
    wxPAPER_ENV_C3,
    wxPAPER_ENV_C4,
    wxPAPER_ENV_C6,
    wxPAPER_ENV_C65,
    wxPAPER_ENV_B4,
    wxPAPER_ENV_B5,
    wxPAPER_ENV_B6,
    wxPAPER_ENV_ITALY,
    wxPAPER_ENV_MONARCH,
    wxPAPER_ENV_PERSONAL,
    wxPAPER_FANFOLD_US,
    wxPAPER_FANFOLD_STD_GERMAN,
    wxPAPER_FANFOLD_LGL_GERMAN,

    wxPAPER_ISO_B4,
    wxPAPER_JAPANESE_POSTCARD,
    wxPAPER_9X11,
    wxPAPER_10X11,
    wxPAPER_15X11,
    wxPAPER_ENV_INVITE,
    wxPAPER_LETTER_EXTRA,
    wxPAPER_LEGAL_EXTRA,
    wxPAPER_TABLOID_EXTRA,
    wxPAPER_A4_EXTRA,
    wxPAPER_LETTER_TRANSVERSE,
    wxPAPER_A4_TRANSVERSE,
    wxPAPER_LETTER_EXTRA_TRANSVERSE,
    wxPAPER_A_PLUS,
    wxPAPER_B_PLUS,
    wxPAPER_LETTER_PLUS,
    wxPAPER_A4_PLUS,
    wxPAPER_A5_TRANSVERSE,
    wxPAPER_B5_TRANSVERSE,
    wxPAPER_A3_EXTRA,
    wxPAPER_A5_EXTRA,
    wxPAPER_B5_EXTRA,
    wxPAPER_A2,
    wxPAPER_A3_TRANSVERSE,
    wxPAPER_A3_EXTRA_TRANSVERSE,

    wxPAPER_DBL_JAPANESE_POSTCARD,
    wxPAPER_A6,
    wxPAPER_JENV_KAKU2,
    wxPAPER_JENV_KAKU3,
    wxPAPER_JENV_CHOU3,
    wxPAPER_JENV_CHOU4,
    wxPAPER_LETTER_ROTATED,
    wxPAPER_A3_ROTATED,
    wxPAPER_A4_ROTATED,
    wxPAPER_A5_ROTATED,
    wxPAPER_B4_JIS_ROTATED,
    wxPAPER_B5_JIS_ROTATED,
    wxPAPER_JAPANESE_POSTCARD_ROTATED,
    wxPAPER_DBL_JAPANESE_POSTCARD_ROTATED,
    wxPAPER_A6_ROTATED,
    wxPAPER_JENV_KAKU2_ROTATED,
    wxPAPER_JENV_KAKU3_ROTATED,
    wxPAPER_JENV_CHOU3_ROTATED,
    wxPAPER_JENV_CHOU4_ROTATED,
    wxPAPER_B6_JIS,
    wxPAPER_B6_JIS_ROTATED,
    wxPAPER_12X11,
    wxPAPER_JENV_YOU4,
    wxPAPER_JENV_YOU4_ROTATED,
    wxPAPER_P16K,
    wxPAPER_P32K,
    wxPAPER_P32KBIG,
    wxPAPER_PENV_1,
    wxPAPER_PENV_2,
    wxPAPER_PENV_3,
    wxPAPER_PENV_4,
    wxPAPER_PENV_5,
    wxPAPER_PENV_6,
    wxPAPER_PENV_7,
    wxPAPER_PENV_8,
    wxPAPER_PENV_9,
    wxPAPER_PENV_10,
    wxPAPER_P16K_ROTATED,
    wxPAPER_P32K_ROTATED,
    wxPAPER_P32KBIG_ROTATED,
    wxPAPER_PENV_1_ROTATED,
    wxPAPER_PENV_2_ROTATED,
    wxPAPER_PENV_3_ROTATED,
    wxPAPER_PENV_4_ROTATED,
    wxPAPER_PENV_5_ROTATED,
    wxPAPER_PENV_6_ROTATED,
    wxPAPER_PENV_7_ROTATED,
    wxPAPER_PENV_8_ROTATED,
    wxPAPER_PENV_9_ROTATED,
    wxPAPER_PENV_10_ROTATED
} wxPaperSize;
# 2284 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
enum wxDuplexMode
{
    wxDUPLEX_SIMPLEX,
    wxDUPLEX_HORIZONTAL,
    wxDUPLEX_VERTICAL
};
# 2299 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef int wxPrintQuality;




enum wxPrintMode
{
    wxPRINT_MODE_NONE = 0,
    wxPRINT_MODE_PREVIEW = 1,
    wxPRINT_MODE_FILE = 2,
    wxPRINT_MODE_PRINTER = 3,
    wxPRINT_MODE_STREAM = 4
};





enum wxUpdateUI
{
    wxUPDATE_UI_NONE = 0x0000,
    wxUPDATE_UI_RECURSE = 0x0001,
    wxUPDATE_UI_FROMIDLE = 0x0002
};





enum wxNotificationOptions
{
    wxNOTIFY_NONE = 0x0000,
    wxNOTIFY_ONCE = 0x0001,
    wxNOTIFY_REPEAT = 0x0002
};
# 2377 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef unsigned char WXCOLORREF[6];
typedef void* WXCGIMAGEREF;
typedef void* WXHBITMAP;
typedef void* WXHCURSOR;
typedef void* WXHRGN;
typedef void* WXRECTPTR;
typedef void* WXPOINTPTR;
typedef void* WXHWND;
typedef void* WXEVENTREF;
typedef void* WXEVENTHANDLERREF;
typedef void* WXEVENTHANDLERCALLREF;
typedef void* WXAPPLEEVENTREF;
typedef void* WXHDC;
typedef void* WXHMENU;
typedef unsigned int WXUINT;
typedef unsigned long WXDWORD;
typedef unsigned short WXWORD;

typedef struct wxOpaqueCIconHandle * WXHICON ;
typedef struct wxOpaquePicHandle * WXHMETAFILE ;




typedef struct wxOpaqueControlRef * WXWidget ;
typedef struct wxOpaqueWindowRef * WXWindow ;
typedef void* WXDisplay;
# 2452 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
    typedef float CGFloat;






typedef int NSInteger;
typedef unsigned int NSUInteger;
# 2501 "/Development/gefri/build/../libs/wx/include/wx/defs.h"
typedef struct NSApplication *WX_NSApplication;
typedef struct NSBitmapImageRep *WX_NSBitmapImageRep;
typedef struct NSBox *WX_NSBox;
typedef struct NSButton *WX_NSButton;
typedef struct NSColor *WX_NSColor;
typedef struct NSColorPanel *WX_NSColorPanel;
typedef struct NSControl *WX_NSControl;
typedef struct NSCursor *WX_NSCursor;
typedef struct NSEvent *WX_NSEvent;
typedef struct NSFontPanel *WX_NSFontPanel;
typedef struct NSImage *WX_NSImage;
typedef struct NSLayoutManager *WX_NSLayoutManager;
typedef struct NSMenu *WX_NSMenu;
typedef struct NSMenuExtra *WX_NSMenuExtra;
typedef struct NSMenuItem *WX_NSMenuItem;
typedef struct NSMutableArray *WX_NSMutableArray;
typedef struct NSNotification *WX_NSNotification;
typedef struct NSObject *WX_NSObject;
typedef struct NSPanel *WX_NSPanel;
typedef struct NSScrollView *WX_NSScrollView;
typedef struct NSSound *WX_NSSound;
typedef struct NSStatusItem *WX_NSStatusItem;
typedef struct NSTableColumn *WX_NSTableColumn;
typedef struct NSTableView *WX_NSTableView;
typedef struct NSTextContainer *WX_NSTextContainer;
typedef struct NSTextField *WX_NSTextField;
typedef struct NSTextStorage *WX_NSTextStorage;
typedef struct NSThread *WX_NSThread;
typedef struct NSWindow *WX_NSWindow;
typedef struct NSView *WX_NSView;


typedef struct NSString *WX_NSString;
# 20 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h" 2
# 1 "/Development/gefri/build/../libs/wx/include/wx/list.h" 1
# 33 "/Development/gefri/build/../libs/wx/include/wx/list.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/object.h" 1
# 20 "/Development/gefri/build/../libs/wx/include/wx/object.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/memory.h" 1
# 16 "/Development/gefri/build/../libs/wx/include/wx/memory.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/string.h" 1
# 42 "/Development/gefri/build/../libs/wx/include/wx/string.h"
# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/limits.h" 1 3 4






# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/syslimits.h" 1 3 4
# 8 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/limits.h" 2 3 4
# 43 "/Development/gefri/build/../libs/wx/include/wx/string.h" 2
# 55 "/Development/gefri/build/../libs/wx/include/wx/string.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/buffer.h" 1
# 127 "/Development/gefri/build/../libs/wx/include/wx/buffer.h"
class wxCharBuffer { public: wxCharBuffer(const char *str = __null) : m_str(str ? strdup(str) : __null) { } wxCharBuffer(size_t len) : m_str((char *)malloc((len + 1)*sizeof(char))) { m_str[len] = (char)0; } ~wxCharBuffer() { free(m_str); } char *release() const { char *p = m_str; ((wxCharBuffer *)this)->m_str = __null; return p; } void reset() { free(m_str); m_str = __null; } wxCharBuffer(const wxCharBuffer& src) : m_str(src.release()) { } wxCharBuffer& operator=(const char *str) { free(m_str); m_str = str ? strdup(str) : __null; return *this; } wxCharBuffer& operator=(const wxCharBuffer& src) { free(m_str); m_str = src.release(); return *this; } bool extend(size_t len) { char * str = (char *)realloc(m_str, (len + 1)*sizeof(char)); if ( !str ) return false; m_str = str; return true; } char *data() { return m_str; } const char *data() const { return m_str; } operator const char *() const { return m_str; } char operator[](size_t n) const { return m_str[n]; } private: char *m_str; };

class wxWritableCharBuffer : public wxCharBuffer { public: wxWritableCharBuffer(const wxCharBuffer& src) : wxCharBuffer(src) {} wxWritableCharBuffer(const char *str = __null) : wxCharBuffer(str) {} operator char*() { return this->data(); } };




class wxWCharBuffer { public: wxWCharBuffer(const wchar_t *str = __null) : m_str(str ? wxStrdupW(str) : __null) { } wxWCharBuffer(size_t len) : m_str((wchar_t *)malloc((len + 1)*sizeof(wchar_t))) { m_str[len] = (wchar_t)0; } ~wxWCharBuffer() { free(m_str); } wchar_t *release() const { wchar_t *p = m_str; ((wxWCharBuffer *)this)->m_str = __null; return p; } void reset() { free(m_str); m_str = __null; } wxWCharBuffer(const wxWCharBuffer& src) : m_str(src.release()) { } wxWCharBuffer& operator=(const wchar_t *str) { free(m_str); m_str = str ? wxStrdupW(str) : __null; return *this; } wxWCharBuffer& operator=(const wxWCharBuffer& src) { free(m_str); m_str = src.release(); return *this; } bool extend(size_t len) { wchar_t * str = (wchar_t *)realloc(m_str, (len + 1)*sizeof(wchar_t)); if ( !str ) return false; m_str = str; return true; } wchar_t *data() { return m_str; } const wchar_t *data() const { return m_str; } operator const wchar_t *() const { return m_str; } wchar_t operator[](size_t n) const { return m_str[n]; } private: wchar_t *m_str; };

class wxWritableWCharBuffer : public wxWCharBuffer { public: wxWritableWCharBuffer(const wxWCharBuffer& src) : wxWCharBuffer(src) {} wxWritableWCharBuffer(const wchar_t *str = __null) : wxWCharBuffer(str) {} operator wchar_t*() { return this->data(); } };
# 145 "/Development/gefri/build/../libs/wx/include/wx/buffer.h"
    typedef wxWCharBuffer wxWxCharBuffer;
# 165 "/Development/gefri/build/../libs/wx/include/wx/buffer.h"
class wxMemoryBufferData
{
public:

    enum { DefBufSize = 1024 };

    friend class wxMemoryBuffer;


private:
    wxMemoryBufferData(size_t size = wxMemoryBufferData::DefBufSize)
        : m_data(size ? malloc(size) : __null), m_size(size), m_len(0), m_ref(0)
    {
    }
    ~wxMemoryBufferData() { free(m_data); }


    void ResizeIfNeeded(size_t newSize)
    {
        if (newSize > m_size)
        {
            void *dataOld = m_data;
            m_data = realloc(m_data, newSize + wxMemoryBufferData::DefBufSize);
            if ( !m_data )
            {
                free(dataOld);
            }

            m_size = newSize + wxMemoryBufferData::DefBufSize;
        }
    }

    void IncRef() { m_ref += 1; }
    void DecRef()
    {
        m_ref -= 1;
        if (m_ref == 0)
            delete this;
    }



    void *m_data;


    size_t m_size;


    size_t m_len;


    size_t m_ref;

    private: wxMemoryBufferData(const wxMemoryBufferData&); wxMemoryBufferData& operator=(const wxMemoryBufferData&);
};


class wxMemoryBuffer
{
public:

    wxMemoryBuffer(size_t size = wxMemoryBufferData::DefBufSize)
    {
        m_bufdata = new wxMemoryBufferData(size);
        m_bufdata->IncRef();
    }

    ~wxMemoryBuffer() { m_bufdata->DecRef(); }



    wxMemoryBuffer(const wxMemoryBuffer& src)
        : m_bufdata(src.m_bufdata)
    {
        m_bufdata->IncRef();
    }

    wxMemoryBuffer& operator=(const wxMemoryBuffer& src)
    {
        m_bufdata->DecRef();
        m_bufdata = src.m_bufdata;
        m_bufdata->IncRef();
        return *this;
    }



    void *GetData() const { return m_bufdata->m_data; }
    size_t GetBufSize() const { return m_bufdata->m_size; }
    size_t GetDataLen() const { return m_bufdata->m_len; }

    void SetBufSize(size_t size) { m_bufdata->ResizeIfNeeded(size); }
    void SetDataLen(size_t len)
    {
        if ( len <= m_bufdata->m_size ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/buffer.h", 259, __FUNCTION__, L"len <= m_bufdata->m_size", __null);
        m_bufdata->m_len = len;
    }


    void *GetWriteBuf(size_t sizeNeeded)
    {
        m_bufdata->ResizeIfNeeded(sizeNeeded);
        return m_bufdata->m_data;
    }


    void UngetWriteBuf(size_t sizeUsed) { SetDataLen(sizeUsed); }


    void *GetAppendBuf(size_t sizeNeeded)
    {
        m_bufdata->ResizeIfNeeded(m_bufdata->m_len + sizeNeeded);
        return (char*)m_bufdata->m_data + m_bufdata->m_len;
    }


    void UngetAppendBuf(size_t sizeUsed)
    {
        SetDataLen(m_bufdata->m_len + sizeUsed);
    }


    void AppendByte(char data)
    {
        if ( m_bufdata->m_data ) ; else { wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/buffer.h", 289, __FUNCTION__, L"m_bufdata->m_data", L"invalid wxMemoryBuffer"); return; } typedef int wxDummyCheckInt;

        m_bufdata->ResizeIfNeeded(m_bufdata->m_len + 1);
        *(((char*)m_bufdata->m_data) + m_bufdata->m_len) = data;
        m_bufdata->m_len += 1;
    }

    void AppendData(const void *data, size_t len)
    {
        memcpy(GetAppendBuf(len), data, len);
        UngetAppendBuf(len);
    }

    operator const char *() const { return (const char*)GetData(); }

private:
    wxMemoryBufferData* m_bufdata;
};
# 56 "/Development/gefri/build/../libs/wx/include/wx/string.h" 2
# 1 "/Development/gefri/build/../libs/wx/include/wx/strconv.h" 1
# 52 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
class wxMBConv
{
public:
# 78 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;

    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;





    const wxWCharBuffer cMB2WC(const char *in) const;
    const wxCharBuffer cWC2MB(const wchar_t *in) const;
# 103 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
    const wxWCharBuffer
        cMB2WC(const char *in, size_t inLen, size_t *outLen) const;
    const wxCharBuffer
        cWC2MB(const wchar_t *in, size_t inLen, size_t *outLen) const;



    const wxWCharBuffer cMB2WX(const char *psz) const { return cMB2WC(psz); }
    const wxCharBuffer cWX2MB(const wchar_t *psz) const { return cWC2MB(psz); }
    const wchar_t* cWC2WX(const wchar_t *psz) const { return psz; }
    const wchar_t* cWX2WC(const wchar_t *psz) const { return psz; }
# 132 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
    virtual size_t GetMBNulLen() const { return 1; }



    static size_t GetMaxMBNulLen() { return 4 ; }
# 155 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
    virtual size_t MB2WC(wchar_t *out, const char *in, size_t outLen) const;
    virtual size_t WC2MB(char *out, const wchar_t *in, size_t outLen) const;



    virtual wxMBConv *Clone() const = 0;


    virtual ~wxMBConv();
};






class wxMBConvLibc : public wxMBConv
{
public:
    virtual size_t MB2WC(wchar_t *outputBuf, const char *psz, size_t outputSize) const;
    virtual size_t WC2MB(char *outputBuf, const wchar_t *psz, size_t outputSize) const;

    virtual wxMBConv *Clone() const { return new wxMBConvLibc; }
};
# 189 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
class wxConvBrokenFileNames : public wxMBConv
{
public:
    wxConvBrokenFileNames(const wxChar *charset);
    wxConvBrokenFileNames(const wxConvBrokenFileNames& conv)
        : wxMBConv(),
          m_conv(conv.m_conv ? conv.m_conv->Clone() : __null)
    {
    }
    virtual ~wxConvBrokenFileNames() { delete m_conv; }

    virtual size_t MB2WC(wchar_t *out, const char *in, size_t outLen) const
    {
        return m_conv->MB2WC(out, in, outLen);
    }

    virtual size_t WC2MB(char *out, const wchar_t *in, size_t outLen) const
    {
        return m_conv->WC2MB(out, in, outLen);
    }

    virtual size_t GetMBNulLen() const
    {

        return m_conv->GetMBNulLen();
    }

    virtual wxMBConv *Clone() const { return new wxConvBrokenFileNames(*this); }

private:

    wxMBConv *m_conv;

    private: wxConvBrokenFileNames& operator=(const wxConvBrokenFileNames&);
};







class wxMBConvUTF7 : public wxMBConv
{
public:
    virtual size_t MB2WC(wchar_t *outputBuf, const char *psz, size_t outputSize) const;
    virtual size_t WC2MB(char *outputBuf, const wchar_t *psz, size_t outputSize) const;

    virtual wxMBConv *Clone() const { return new wxMBConvUTF7; }
};





class wxMBConvUTF8 : public wxMBConv
{
public:
    enum
    {
        MAP_INVALID_UTF8_NOT = 0,
        MAP_INVALID_UTF8_TO_PUA = 1,
        MAP_INVALID_UTF8_TO_OCTAL = 2
    };

    wxMBConvUTF8(int options = MAP_INVALID_UTF8_NOT) : m_options(options) { }
    virtual size_t MB2WC(wchar_t *outputBuf, const char *psz, size_t outputSize) const;
    virtual size_t WC2MB(char *outputBuf, const wchar_t *psz, size_t outputSize) const;

    virtual wxMBConv *Clone() const { return new wxMBConvUTF8(m_options); }

private:
    int m_options;
};





class wxMBConvUTF16Base : public wxMBConv
{
public:
    enum { BYTES_PER_CHAR = 2 };

    virtual size_t GetMBNulLen() const { return BYTES_PER_CHAR; }

protected:




    static size_t GetLength(const char *src, size_t srcLen);
};





class wxMBConvUTF16LE : public wxMBConvUTF16Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF16LE; }
};





class wxMBConvUTF16BE : public wxMBConvUTF16Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF16BE; }
};





class wxMBConvUTF32Base : public wxMBConv
{
public:
    enum { BYTES_PER_CHAR = 4 };

    virtual size_t GetMBNulLen() const { return BYTES_PER_CHAR; }

protected:



    static size_t GetLength(const char *src, size_t srcLen);
};





class wxMBConvUTF32LE : public wxMBConvUTF32Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF32LE; }
};





class wxMBConvUTF32BE : public wxMBConvUTF32Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF32BE; }
};





# 1 "/Development/gefri/build/../libs/wx/include/wx/fontenc.h" 1
# 16 "/Development/gefri/build/../libs/wx/include/wx/fontenc.h"
enum wxFontEncoding
{
    wxFONTENCODING_SYSTEM = -1,
    wxFONTENCODING_DEFAULT,


    wxFONTENCODING_ISO8859_1,
    wxFONTENCODING_ISO8859_2,
    wxFONTENCODING_ISO8859_3,
    wxFONTENCODING_ISO8859_4,
    wxFONTENCODING_ISO8859_5,
    wxFONTENCODING_ISO8859_6,
    wxFONTENCODING_ISO8859_7,
    wxFONTENCODING_ISO8859_8,
    wxFONTENCODING_ISO8859_9,
    wxFONTENCODING_ISO8859_10,
    wxFONTENCODING_ISO8859_11,
    wxFONTENCODING_ISO8859_12,


    wxFONTENCODING_ISO8859_13,
    wxFONTENCODING_ISO8859_14,
    wxFONTENCODING_ISO8859_15,
    wxFONTENCODING_ISO8859_MAX,


    wxFONTENCODING_KOI8,
    wxFONTENCODING_KOI8_U,
    wxFONTENCODING_ALTERNATIVE,
    wxFONTENCODING_BULGARIAN,



    wxFONTENCODING_CP437,
    wxFONTENCODING_CP850,
    wxFONTENCODING_CP852,
    wxFONTENCODING_CP855,
    wxFONTENCODING_CP866,

    wxFONTENCODING_CP874,
    wxFONTENCODING_CP932,
    wxFONTENCODING_CP936,
    wxFONTENCODING_CP949,
    wxFONTENCODING_CP950,
    wxFONTENCODING_CP1250,
    wxFONTENCODING_CP1251,
    wxFONTENCODING_CP1252,
    wxFONTENCODING_CP1253,
    wxFONTENCODING_CP1254,
    wxFONTENCODING_CP1255,
    wxFONTENCODING_CP1256,
    wxFONTENCODING_CP1257,
    wxFONTENCODING_CP12_MAX,

    wxFONTENCODING_UTF7,
    wxFONTENCODING_UTF8,
    wxFONTENCODING_EUC_JP,
    wxFONTENCODING_UTF16BE,
    wxFONTENCODING_UTF16LE,
    wxFONTENCODING_UTF32BE,
    wxFONTENCODING_UTF32LE,

    wxFONTENCODING_MACROMAN,
    wxFONTENCODING_MACJAPANESE,
    wxFONTENCODING_MACCHINESETRAD,
    wxFONTENCODING_MACKOREAN,
    wxFONTENCODING_MACARABIC,
    wxFONTENCODING_MACHEBREW,
    wxFONTENCODING_MACGREEK,
    wxFONTENCODING_MACCYRILLIC,
    wxFONTENCODING_MACDEVANAGARI,
    wxFONTENCODING_MACGURMUKHI,
    wxFONTENCODING_MACGUJARATI,
    wxFONTENCODING_MACORIYA,
    wxFONTENCODING_MACBENGALI,
    wxFONTENCODING_MACTAMIL,
    wxFONTENCODING_MACTELUGU,
    wxFONTENCODING_MACKANNADA,
    wxFONTENCODING_MACMALAJALAM,
    wxFONTENCODING_MACSINHALESE,
    wxFONTENCODING_MACBURMESE,
    wxFONTENCODING_MACKHMER,
    wxFONTENCODING_MACTHAI,
    wxFONTENCODING_MACLAOTIAN,
    wxFONTENCODING_MACGEORGIAN,
    wxFONTENCODING_MACARMENIAN,
    wxFONTENCODING_MACCHINESESIMP,
    wxFONTENCODING_MACTIBETAN,
    wxFONTENCODING_MACMONGOLIAN,
    wxFONTENCODING_MACETHIOPIC,
    wxFONTENCODING_MACCENTRALEUR,
    wxFONTENCODING_MACVIATNAMESE,
    wxFONTENCODING_MACARABICEXT,
    wxFONTENCODING_MACSYMBOL,
    wxFONTENCODING_MACDINGBATS,
    wxFONTENCODING_MACTURKISH,
    wxFONTENCODING_MACCROATIAN,
    wxFONTENCODING_MACICELANDIC,
    wxFONTENCODING_MACROMANIAN,
    wxFONTENCODING_MACCELTIC,
    wxFONTENCODING_MACGAELIC,
    wxFONTENCODING_MACKEYBOARD,

    wxFONTENCODING_MAX,

    wxFONTENCODING_MACMIN = wxFONTENCODING_MACROMAN ,
    wxFONTENCODING_MACMAX = wxFONTENCODING_MACKEYBOARD ,






    wxFONTENCODING_UTF16 = wxFONTENCODING_UTF16LE,
    wxFONTENCODING_UTF32 = wxFONTENCODING_UTF32LE,







    wxFONTENCODING_UNICODE = wxFONTENCODING_UTF32,




    wxFONTENCODING_GB2312 = wxFONTENCODING_CP936,
    wxFONTENCODING_BIG5 = wxFONTENCODING_CP950,


    wxFONTENCODING_SHIFT_JIS = wxFONTENCODING_CP932
};
# 362 "/Development/gefri/build/../libs/wx/include/wx/strconv.h" 2

class wxCSConv : public wxMBConv
{
public:


    wxCSConv(const wxChar *charset);
    wxCSConv(wxFontEncoding encoding);

    wxCSConv(const wxCSConv& conv);
    virtual ~wxCSConv();

    wxCSConv& operator=(const wxCSConv& conv);

    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t MB2WC(wchar_t *outputBuf, const char *psz, size_t outputSize) const;
    virtual size_t WC2MB(char *outputBuf, const wchar_t *psz, size_t outputSize) const;
    virtual size_t GetMBNulLen() const;

    virtual wxMBConv *Clone() const { return new wxCSConv(*this); }

    void Clear();



    bool IsOk() const;


private:

    void Init();


    void CreateConvIfNeeded() const;


    wxMBConv *DoCreate() const;



    void SetName(const wxChar *charset);




    wxChar *m_name;
    wxFontEncoding m_encoding;


    wxMBConv *m_convReal;
    bool m_deferred;
};
# 425 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
extern wxMBConv& wxConvLibc;


extern wxCSConv& wxConvISO8859_1;
extern wxMBConvUTF7& wxConvUTF7;
extern wxMBConvUTF8& wxConvUTF8;
# 439 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
extern wxMBConv * wxConvFileName;






extern wxMBConv * wxConvCurrent;


extern wxCSConv& wxConvLocal;





extern wxMBConv * wxConvUI;
# 465 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
    typedef wxMBConvUTF16LE wxMBConvUTF16;
    typedef wxMBConvUTF32LE wxMBConvUTF32;
# 538 "/Development/gefri/build/../libs/wx/include/wx/strconv.h"
    extern wxWCharBuffer wxSafeConvertMB2WX(const char *s);



    extern wxCharBuffer wxSafeConvertWX2MB(const wchar_t *ws);
# 57 "/Development/gefri/build/../libs/wx/include/wx/string.h" 2

class wxString;
# 93 "/Development/gefri/build/../libs/wx/include/wx/string.h"
extern const wxChar* wxEmptyString;
# 104 "/Development/gefri/build/../libs/wx/include/wx/string.h"
inline bool IsEmpty(const char *p) { return (!p || !*p); }


inline size_t Strlen(const char *psz)
  { return psz ? strlen(psz) : 0; }


inline int Stricmp(const char *psz1, const char *psz2)
{
# 141 "/Development/gefri/build/../libs/wx/include/wx/string.h"
  return strcasecmp(psz1, psz2);
# 166 "/Development/gefri/build/../libs/wx/include/wx/string.h"
}
# 216 "/Development/gefri/build/../libs/wx/include/wx/string.h"
struct wxStringData
{
  int nRefs;
  size_t nDataLength,
          nAllocLength;


  wxChar* data() const { return (wxChar*)(this + 1); }


  bool IsEmpty() const { return (nRefs == -1); }
  bool IsShared() const { return (nRefs > 1); }


  void Lock() { if ( !IsEmpty() ) nRefs++; }
# 243 "/Development/gefri/build/../libs/wx/include/wx/string.h"
  void Unlock() { if ( !IsEmpty() && --nRefs == 0) free(this); }




  void Validate(bool b) { nRefs = (b ? 1 : 0); }
  bool IsValid() const { return (nRefs != 0); }
};

class wxStringBase
{

friend class wxArrayString;

public :

  static const size_t npos;
protected:

  wxChar *m_pchData;


  wxStringData* GetStringData() const { return (wxStringData*)m_pchData - 1; }




  void Init() { m_pchData = (wxChar *)wxEmptyString; }

  void InitWith(const wxChar *psz, size_t nPos = 0, size_t nLen = npos);

  void Reinit() { GetStringData()->Unlock(); Init(); }



  bool AllocBuffer(size_t nLen);

  bool AllocCopy(wxString&, int, int) const;

  bool AssignCopy(size_t, const wxChar *);


  bool ConcatSelf(size_t nLen, const wxChar *src, size_t nMaxLen);
  bool ConcatSelf(size_t nLen, const wxChar *src)
    { return ConcatSelf(nLen, src, nLen); }



  bool CopyBeforeWrite();
  bool AllocBeforeWrite(size_t);


  bool Alloc(size_t nLen);
public:

  typedef wxChar value_type;
  typedef wxChar char_type;
  typedef size_t size_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type *iterator;
  typedef const value_type *const_iterator;
# 336 "/Development/gefri/build/../libs/wx/include/wx/string.h"
  class const_reverse_iterator { public: typedef wxChar value_type; typedef const value_type& reference; typedef const value_type *pointer; typedef const value_type *iterator_type; const_reverse_iterator(iterator_type i) : m_cur(i) { } const_reverse_iterator(const const_reverse_iterator& ri) : m_cur(ri.m_cur) { } iterator_type base() const { return m_cur; } reference operator*() const { return *(m_cur - 1); } const_reverse_iterator& operator++() { --m_cur; return *this; } const_reverse_iterator operator++(int) { const_reverse_iterator tmp = *this; --m_cur; return tmp; } const_reverse_iterator& operator--() { ++m_cur; return *this; } const_reverse_iterator operator--(int) { const_reverse_iterator tmp = *this; ++m_cur; return tmp; } bool operator==(const_reverse_iterator ri) const { return m_cur == ri.m_cur; } bool operator!=(const_reverse_iterator ri) const { return !(*this == ri); } private: iterator_type m_cur; };


  class reverse_iterator { public: typedef wxChar value_type; typedef value_type& reference; typedef value_type *pointer; typedef value_type *iterator_type; reverse_iterator(iterator_type i) : m_cur(i) { } reverse_iterator(const reverse_iterator& ri) : m_cur(ri.m_cur) { } iterator_type base() const { return m_cur; } reference operator*() const { return *(m_cur - 1); } reverse_iterator& operator++() { --m_cur; return *this; } reverse_iterator operator++(int) { reverse_iterator tmp = *this; --m_cur; return tmp; } reverse_iterator& operator--() { ++m_cur; return *this; } reverse_iterator operator--(int) { reverse_iterator tmp = *this; ++m_cur; return tmp; } bool operator==(reverse_iterator ri) const { return m_cur == ri.m_cur; } bool operator!=(reverse_iterator ri) const { return !(*this == ri); } private: iterator_type m_cur; };







  wxStringBase() { Init(); }

  wxStringBase(const wxStringBase& stringSrc)
  {
    if ( stringSrc.GetStringData()->IsValid() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 352, __FUNCTION__, L"stringSrc.GetStringData()->IsValid()", L"did you forget to call UngetWriteBuf()?");


    if ( stringSrc.empty() ) {

      Init();
    }
    else {
      m_pchData = stringSrc.m_pchData;
      GetStringData()->Lock();
    }
  }

  wxStringBase(size_type nRepeat, wxChar ch);


  wxStringBase(const wxChar *psz)
      { InitWith(psz, 0, npos); }
  wxStringBase(const wxChar *psz, size_t nLength)
      { InitWith(psz, 0, nLength); }
  wxStringBase(const wxChar *psz,
               const wxMBConv& ,
               size_t nLength = npos)
      { InitWith(psz, 0, nLength); }

  wxStringBase(const wxStringBase& str, size_t nPos, size_t nLen)
  {
    if ( str.GetStringData()->IsValid() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 379, __FUNCTION__, L"str.GetStringData()->IsValid()", L"did you forget to call UngetWriteBuf()?");

    Init();
    size_t strLen = str.length() - nPos; nLen = strLen < nLen ? strLen : nLen;
    InitWith(str.c_str(), nPos, nLen);
  }

  wxStringBase(const void *pStart, const void *pEnd);


  ~wxStringBase()
  {






      GetStringData()->Unlock();
  }







  wxStringBase& operator=(const wxStringBase& stringSrc);

  wxStringBase& operator=(wxChar ch);

  wxStringBase& operator=(const wxChar *psz);


  size_type length() const { return GetStringData()->nDataLength; }

  size_type size() const { return length(); }

  size_type max_size() const { return npos; }

  void resize(size_t nSize, wxChar ch = L'\0');

  void clear() { erase(0, npos); }

  bool empty() const { return length() == 0; }

  void reserve(size_t sz) { Alloc(sz); }
  size_type capacity() const { return GetStringData()->nAllocLength; }



  value_type at(size_type n) const
    { if ( (size_t)(n) <= length() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 430, __FUNCTION__, L"(size_t)(n) <= length()", L"invalid index in wxString"); return m_pchData[n]; }

  reference at(size_type n)
    { if ( (size_t)(n) <= length() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 433, __FUNCTION__, L"(size_t)(n) <= length()", L"invalid index in wxString"); CopyBeforeWrite(); return m_pchData[n]; }



  wxStringBase& append(const wxStringBase& str, size_t pos, size_t n)
  {
    if ( pos <= str.length() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 439, __FUNCTION__, L"pos <= str.length()", __null);
    ConcatSelf(n, str.c_str() + pos, str.length() - pos);
    return *this;
  }

  wxStringBase& append(const wxStringBase& str)
    { ConcatSelf(str.length(), str.c_str()); return *this; }

  wxStringBase& append(const wxChar *sz)
    { ConcatSelf(wxStrlen(sz), sz); return *this; }
  wxStringBase& append(const wxChar *sz, size_t n)
    { ConcatSelf(n, sz); return *this; }

  wxStringBase& append(size_t n, wxChar ch);

  wxStringBase& append(const_iterator first, const_iterator last)
    { ConcatSelf(last - first, first); return *this; }


  wxStringBase& assign(const wxStringBase& str)
    { return *this = str; }

  wxStringBase& assign(const wxStringBase& str, size_t pos, size_t n)
    { clear(); return append(str, pos, n); }

  wxStringBase& assign(const wxChar *sz)
    { clear(); return append(sz, wxStrlen(sz)); }
  wxStringBase& assign(const wxChar *sz, size_t n)
    { clear(); return append(sz, n); }

  wxStringBase& assign(size_t n, wxChar ch)
    { clear(); return append(n, ch); }

  wxStringBase& assign(const_iterator first, const_iterator last)
    { clear(); return append(first, last); }


  const_iterator begin() const { return m_pchData; }
  iterator begin();

  const_iterator end() const { return m_pchData + length(); }
  iterator end();


  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
  reverse_iterator rbegin() { return reverse_iterator(end()); }

  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }


  wxStringBase& insert(size_t nPos, const wxStringBase& str)
  {
    if ( str.GetStringData()->IsValid() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 492, __FUNCTION__, L"str.GetStringData()->IsValid()", __null);
    return insert(nPos, str.c_str(), str.length());
  }

  wxStringBase& insert(size_t nPos, const wxStringBase& str, size_t nStart, size_t n)
  {
    if ( str.GetStringData()->IsValid() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 498, __FUNCTION__, L"str.GetStringData()->IsValid()", __null);
    if ( nStart < str.length() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 499, __FUNCTION__, L"nStart < str.length()", __null);
    size_t strLen = str.length() - nStart;
    n = strLen < n ? strLen : n;
    return insert(nPos, str.c_str() + nStart, n);
  }

  wxStringBase& insert(size_t nPos, const wxChar *sz, size_t n = npos);

  wxStringBase& insert(size_t nPos, size_t n, wxChar ch)
    { return insert(nPos, wxStringBase(n, ch)); }
  iterator insert(iterator it, wxChar ch)
    { size_t idx = it - begin(); insert(idx, 1, ch); return begin() + idx; }
  void insert(iterator it, const_iterator first, const_iterator last)
    { insert(it - begin(), first, last - first); }
  void insert(iterator it, size_type n, wxChar ch)
    { insert(it - begin(), n, ch); }


  wxStringBase& erase(size_type pos = 0, size_type n = npos);
  iterator erase(iterator first, iterator last)
  {
    size_t idx = first - begin();
    erase(idx, last - first);
    return begin() + idx;
  }
  iterator erase(iterator first);


  const wxChar* c_str() const { return m_pchData; }
  const wxChar* data() const { return m_pchData; }


  wxStringBase& replace(size_t nStart, size_t nLen, const wxChar* sz);

  wxStringBase& replace(size_t nStart, size_t nLen, const wxStringBase& str)
    { return replace(nStart, nLen, str.c_str()); }

  wxStringBase& replace(size_t nStart, size_t nLen, size_t nCount, wxChar ch);

  wxStringBase& replace(size_t nStart, size_t nLen,
                        const wxStringBase& str, size_t nStart2, size_t nLen2);

  wxStringBase& replace(size_t nStart, size_t nLen,
                        const wxChar* sz, size_t nCount);
  wxStringBase& replace(iterator first, iterator last, const_pointer s)
    { return replace(first - begin(), last - first, s); }
  wxStringBase& replace(iterator first, iterator last, const_pointer s,
                        size_type n)
    { return replace(first - begin(), last - first, s, n); }
  wxStringBase& replace(iterator first, iterator last, const wxStringBase& s)
    { return replace(first - begin(), last - first, s); }
  wxStringBase& replace(iterator first, iterator last, size_type n, wxChar c)
    { return replace(first - begin(), last - first, n, c); }
  wxStringBase& replace(iterator first, iterator last,
                        const_iterator first1, const_iterator last1)
    { return replace(first - begin(), last - first, first1, last1 - first1); }


  void swap(wxStringBase& str);






  size_t find(const wxStringBase& str, size_t nStart = 0) const;


  size_t find(const wxChar* sz, size_t nStart = 0, size_t n = npos) const;


  size_t find(wxChar ch, size_t nStart = 0) const;




  size_t rfind(const wxStringBase& str, size_t nStart = npos) const;


  size_t rfind(const wxChar* sz, size_t nStart = npos,
               size_t n = npos) const;

  size_t rfind(wxChar ch, size_t nStart = npos) const;




  size_t find_first_of(const wxStringBase& str, size_t nStart = 0) const
    { return find_first_of(str.c_str(), nStart); }

  size_t find_first_of(const wxChar* sz, size_t nStart = 0) const;
  size_t find_first_of(const wxChar* sz, size_t nStart, size_t n) const;

  size_t find_first_of(wxChar c, size_t nStart = 0) const
    { return find(c, nStart); }

  size_t find_last_of (const wxStringBase& str, size_t nStart = npos) const
    { return find_last_of(str.c_str(), nStart); }

  size_t find_last_of (const wxChar* sz, size_t nStart = npos) const;
  size_t find_last_of(const wxChar* sz, size_t nStart, size_t n) const;

  size_t find_last_of(wxChar c, size_t nStart = npos) const
    { return rfind(c, nStart); }




  size_t find_first_not_of(const wxStringBase& str, size_t nStart = 0) const
    { return find_first_not_of(str.c_str(), nStart); }

  size_t find_first_not_of(const wxChar* sz, size_t nStart = 0) const;
  size_t find_first_not_of(const wxChar* sz, size_t nStart, size_t n) const;

  size_t find_first_not_of(wxChar ch, size_t nStart = 0) const;

  size_t find_last_not_of(const wxStringBase& str, size_t nStart = npos) const
    { return find_last_not_of(str.c_str(), nStart); }

  size_t find_last_not_of(const wxChar* sz, size_t nStart = npos) const;
  size_t find_last_not_of(const wxChar* sz, size_t nStart, size_t n) const;

  size_t find_last_not_of(wxChar ch, size_t nStart = npos) const;





  int compare(const wxStringBase& str) const;

  int compare(size_t nStart, size_t nLen, const wxStringBase& str) const;

  int compare(size_t nStart, size_t nLen,
              const wxStringBase& str, size_t nStart2, size_t nLen2) const;

  int compare(const wxChar* sz) const;

  int compare(size_t nStart, size_t nLen,
              const wxChar* sz, size_t nCount = npos) const;

  size_type copy(wxChar* s, size_type n, size_type pos = 0);


  wxStringBase substr(size_t nStart = 0, size_t nLen = npos) const;


  wxStringBase& operator+=(const wxStringBase& s) { return append(s); }

  wxStringBase& operator+=(const wxChar *psz) { return append(psz); }

  wxStringBase& operator+=(wxChar ch) { return append(1, ch); }
};
# 659 "/Development/gefri/build/../libs/wx/include/wx/string.h"
class wxString : public wxStringBase
{

friend class wxArrayString;





private:







  wxString& operator=(int);





  wxString(int);

public:


  wxString() : wxStringBase() { }

  wxString(const wxStringBase& stringSrc) : wxStringBase(stringSrc) { }
  wxString(const wxString& stringSrc) : wxStringBase(stringSrc) { }

  wxString(wxChar ch, size_t nRepeat = 1)
      : wxStringBase(nRepeat, ch) { }
  wxString(size_t nRepeat, wxChar ch)
      : wxStringBase(nRepeat, ch) { }


  wxString(const wxChar *psz)
      : wxStringBase(psz ? psz : L"") { }
  wxString(const wxChar *psz, size_t nLength)
      : wxStringBase(psz, nLength) { }
  wxString(const wxChar *psz,
           const wxMBConv& ,
           size_t nLength = npos)
      : wxStringBase(psz, nLength == npos ? wxStrlen(psz) : nLength) { }
# 720 "/Development/gefri/build/../libs/wx/include/wx/string.h"
  wxString(const char *psz, const wxMBConv& conv, size_t nLength = npos);

  wxString(const wxWCharBuffer& psz) : wxStringBase(psz.data()) { }
# 745 "/Development/gefri/build/../libs/wx/include/wx/string.h"
  size_t Len() const { return length(); }

  bool IsEmpty() const { return empty(); }

  bool operator!() const { return empty(); }

  wxString& Truncate(size_t uiLen);

  void Empty()
  {
    Truncate(0);

    if ( empty() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 757, __FUNCTION__, L"empty()", L"string not empty after call to Empty()?");
  }

  void Clear()
  {
    wxString tmp(wxEmptyString);
    swap(tmp);
  }



  bool IsAscii() const;

  bool IsNumber() const;

  bool IsWord() const;



    wxChar GetChar(size_t n) const
      { return at(n); }

    wxChar& GetWritableChar(size_t n)
      { return at(n); }

    void SetChar(size_t n, wxChar ch)
      { at(n) = ch; }


    wxChar Last() const
      {
          if ( !empty() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 788, __FUNCTION__, L"!empty()", L"wxString: index out of bounds");

          return at(length() - 1);
      }


    wxChar& Last()
      {
          if ( !empty() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 796, __FUNCTION__, L"!empty()", L"wxString: index out of bounds");
          return at(length() - 1);
      }
# 822 "/Development/gefri/build/../libs/wx/include/wx/string.h"
    wxChar& operator[](int n)
      { return wxStringBase::at(n); }
    wxChar& operator[](size_type n)
      { return wxStringBase::at(n); }

    wxChar& operator[](unsigned int n)
      { return wxStringBase::at(n); }



    operator const wxChar*() const { return c_str(); }


    const wxChar* wx_str() const { return c_str(); }

    const wxChar* GetData() const { return c_str(); }





    wxWritableCharBuffer char_str(const wxMBConv& conv = wxConvLibc) const
      { return mb_str(conv); }

    wxWritableWCharBuffer wchar_str() const { return wc_str(wxConvLibc); }
# 857 "/Development/gefri/build/../libs/wx/include/wx/string.h"
    static wxString FromAscii(const char *ascii);
    static wxString FromAscii(const char ascii);
    const wxCharBuffer ToAscii() const;
# 869 "/Development/gefri/build/../libs/wx/include/wx/string.h"
    static wxString FromUTF8(const char *utf8)
      { return wxString(utf8, wxConvUTF8); }
    static wxString FromUTF8(const char *utf8, size_t len)
      { return wxString(utf8, wxConvUTF8, len); }
    const wxCharBuffer utf8_str() const { return mb_str(wxConvUTF8); }
    const wxCharBuffer ToUTF8() const { return utf8_str(); }
# 893 "/Development/gefri/build/../libs/wx/include/wx/string.h"
    static wxString From8BitData(const char *data, size_t len)
      { return wxString(data, wxConvISO8859_1, len); }

    static wxString From8BitData(const char *data)
      { return wxString(data, wxConvISO8859_1); }
    const wxCharBuffer To8BitData() const { return mb_str(wxConvISO8859_1); }
# 919 "/Development/gefri/build/../libs/wx/include/wx/string.h"
    const wxCharBuffer mb_str(const wxMBConv& conv = wxConvLibc) const;

    const wxCharBuffer mbc_str() const { return mb_str(*wxConvCurrent); }

    const wxChar* wc_str() const { return c_str(); }


    const wxChar* wc_str(const wxMBConv& ) const { return c_str(); }


    const wxCharBuffer fn_str() const { return mb_str((*wxConvFileName)); }
# 953 "/Development/gefri/build/../libs/wx/include/wx/string.h"
  wxString& operator=(const wxStringBase& stringSrc)
    { return (wxString&)wxStringBase::operator=(stringSrc); }

  wxString& operator=(wxChar ch)
    { return (wxString&)wxStringBase::operator=(ch); }






  wxString& operator=(const wxChar *psz)
    { return (wxString&)wxStringBase::operator=(psz); }




  wxString& operator=(const wxWCharBuffer& psz)
    { (void) operator=((const wchar_t *)psz); return *this; }
# 992 "/Development/gefri/build/../libs/wx/include/wx/string.h"
  wxString& operator<<(const wxString& s)
  {

    if ( s.GetStringData()->IsValid() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 996, __FUNCTION__, L"s.GetStringData()->IsValid()", L"did you forget to call UngetWriteBuf()?");



    append(s);
    return *this;
  }

  wxString& operator<<(const wxChar *psz)
    { append(psz); return *this; }

  wxString& operator<<(wxChar ch) { append(1, ch); return *this; }



  wxString& operator<<(const wxWCharBuffer& s)
    { (void)operator<<((const wchar_t *)s); return *this; }
  void operator+=(const wxWCharBuffer& s)
    { (void)operator<<((const wchar_t *)s); }
# 1022 "/Development/gefri/build/../libs/wx/include/wx/string.h"
  wxString& Append(const wxString& s)
    {

        if ( empty() )
            *this = s;
        else
            append(s);
        return *this;
    }
  wxString& Append(const wxChar* psz)
    { append(psz); return *this; }

  wxString& Append(wxChar ch, size_t count = 1u)
    { append(count, ch); return *this; }
  wxString& Append(const wxChar* psz, size_t nLen)
    { append(psz, nLen); return *this; }


  wxString& Prepend(const wxString& str)
    { *this = str + *this; return *this; }



  friend wxString operator+(const wxString& string1,
                                             const wxString& string2);

  friend wxString operator+(const wxString& string, wxChar ch);

  friend wxString operator+(wxChar ch, const wxString& string);

  friend wxString operator+(const wxString& string,
                                             const wxChar *psz);

  friend wxString operator+(const wxChar *psz,
                                             const wxString& string);



  wxString& operator<<(int i)
    { return (*this) << Format(L"%d", i); }

  wxString& operator<<(unsigned int ui)
    { return (*this) << Format(L"%u", ui); }

  wxString& operator<<(long l)
    { return (*this) << Format(L"%ld", l); }

  wxString& operator<<(unsigned long ul)
    { return (*this) << Format(L"%lu", ul); }


  wxString& operator<<(long long ll)
    {
      const wxChar *fmt = L"%" L"ll" L"d";
      return (*this) << Format(fmt, ll);
    }

  wxString& operator<<(unsigned long long ull)
    {
      const wxChar *fmt = L"%" L"ll" L"u";
      return (*this) << Format(fmt , ull);
    }


  wxString& operator<<(float f)
    { return (*this) << Format(L"%f", f); }

  wxString& operator<<(double d)
    { return (*this) << Format(L"%g", d); }



  int Cmp(const wxChar *psz) const;
  int Cmp(const wxString& s) const;

  int CmpNoCase(const wxChar *psz) const;
  int CmpNoCase(const wxString& s) const;


  bool IsSameAs(const wxChar *psz, bool compareWithCase = true) const
    { return (compareWithCase ? Cmp(psz) : CmpNoCase(psz)) == 0; }

  bool IsSameAs(wxChar c, bool compareWithCase = true) const
    {
      return (length() == 1) && (compareWithCase ? GetChar(0u) == c
                              : towupper(GetChar(0u)) == towupper(c));
    }




  wxString Mid(size_t nFirst, size_t nCount = npos) const;


  wxString operator()(size_t start, size_t len) const
    { return Mid(start, len); }




  bool StartsWith(const wxChar *prefix, wxString *rest = __null) const;



  bool EndsWith(const wxChar *suffix, wxString *rest = __null) const;


  wxString Left(size_t nCount) const;

  wxString Right(size_t nCount) const;


  wxString BeforeFirst(wxChar ch) const;


  wxString BeforeLast(wxChar ch) const;


  wxString AfterFirst(wxChar ch) const;


  wxString AfterLast(wxChar ch) const;


  wxString Before(wxChar ch) const { return BeforeLast(ch); }
  wxString After(wxChar ch) const { return AfterFirst(ch); }



  wxString& MakeUpper();


  wxString Upper() const ;

  wxString& MakeLower();

  wxString Lower() const ;



  wxString& Trim(bool bFromRight = true);

  wxString& Pad(size_t nCount, wxChar chPad = L' ', bool bFromRight = true);



  int Find(wxChar ch, bool bFromEnd = false) const;

  int Find(const wxChar *pszSub) const;


  size_t Replace(const wxChar *szOld,
                 const wxChar *szNew,
                 bool bReplaceAll = true);


  bool Matches(const wxChar *szMask) const;







    bool ToLong(long *val, int base = 10) const;

    bool ToULong(unsigned long *val, int base = 10) const;


    bool ToLongLong(long long *val, int base = 10) const;

    bool ToULongLong(unsigned long long *val, int base = 10) const;


    bool ToDouble(double *val) const;






  int Printf(const wxChar *pszFormat, ...) ;

  int PrintfV(const wxChar* pszFormat, va_list argptr);


  static wxString Format(const wxChar *pszFormat, ...) ;

  static wxString FormatV(const wxChar *pszFormat, va_list argptr);




  bool Alloc(size_t nLen) { reserve(nLen); return true; }


  bool Shrink();



  wxChar *GetWriteBuf(size_t nLen);

  void UngetWriteBuf();
  void UngetWriteBuf(size_t nLen);





  wxString SubString(size_t from, size_t to) const
      { return Mid(from, (to - from + 1)); }

  enum caseCompare {exact, ignoreCase};

  enum stripType {leading = 0x1, trailing = 0x2, both = 0x3};



  int sprintf(const wxChar *pszFormat, ...) ;


  inline int CompareTo(const wxChar* psz, caseCompare cmp = exact) const
    { return cmp == exact ? Cmp(psz) : CmpNoCase(psz); }


  size_t Length() const { return length(); }

  int Freq(wxChar ch) const;

  void LowerCase() { MakeLower(); }

  void UpperCase() { MakeUpper(); }

  wxString Strip(stripType w = trailing) const;


  size_t Index(const wxChar* psz) const { return Find(psz); }
  size_t Index(wxChar ch) const { return Find(ch); }

  wxString& Remove(size_t pos) { return Truncate(pos); }
  wxString& RemoveLast(size_t n = 1) { return Truncate(length() - n); }

  wxString& Remove(size_t nStart, size_t nLen)
      { return (wxString&)erase( nStart, nLen ); }


  int First( const wxChar ch ) const { return Find(ch); }
  int First( const wxChar* psz ) const { return Find(psz); }
  int First( const wxString &str ) const { return Find(str); }
  int Last( const wxChar ch ) const { return Find(ch, true); }
  bool Contains(const wxString& str) const { return Find(str) != (-1); }


  bool IsNull() const { return empty(); }




  wxString(const wxString& str, size_t nPos, size_t nLen)
      : wxStringBase(str, nPos, nLen) { }

  wxString(const void *pStart, const void *pEnd)
      : wxStringBase((const wxChar*)pStart, (const wxChar*)pEnd) { }







  wxString& append(const wxString& str, size_t pos, size_t n)
    { return (wxString&)wxStringBase::append(str, pos, n); }

  wxString& append(const wxString& str)
    { return (wxString&)wxStringBase::append(str); }

  wxString& append(const wxChar *sz)
    { return (wxString&)wxStringBase::append(sz); }
  wxString& append(const wxChar *sz, size_t n)
    { return (wxString&)wxStringBase::append(sz, n); }

  wxString& append(size_t n, wxChar ch)
    { return (wxString&)wxStringBase::append(n, ch); }

  wxString& append(const_iterator first, const_iterator last)
    { return (wxString&)wxStringBase::append(first, last); }


  wxString& assign(const wxString& str)
    { return (wxString&)wxStringBase::assign(str); }

  wxString& assign(const wxString& str, size_t pos, size_t n)
    { return (wxString&)wxStringBase::assign(str, pos, n); }

  wxString& assign(const wxChar *sz)
    { return (wxString&)wxStringBase::assign(sz); }
  wxString& assign(const wxChar *sz, size_t n)
    { return (wxString&)wxStringBase::assign(sz, n); }

  wxString& assign(size_t n, wxChar ch)
    { return (wxString&)wxStringBase::assign(n, ch); }

  wxString& assign(const_iterator first, const_iterator last)
    { return (wxString&)wxStringBase::assign(first, last); }
# 1343 "/Development/gefri/build/../libs/wx/include/wx/string.h"
  wxString& insert(size_t nPos, const wxString& str)
    { return (wxString&)wxStringBase::insert(nPos, str); }

  wxString& insert(size_t nPos, const wxString& str, size_t nStart, size_t n)
    { return (wxString&)wxStringBase::insert(nPos, str, nStart, n); }

  wxString& insert(size_t nPos, const wxChar *sz)
    { return (wxString&)wxStringBase::insert(nPos, sz); }
  wxString& insert(size_t nPos, const wxChar *sz, size_t n)
    { return (wxString&)wxStringBase::insert(nPos, sz, n); }

  wxString& insert(size_t nPos, size_t n, wxChar ch)
    { return (wxString&)wxStringBase::insert(nPos, n, ch); }
  iterator insert(iterator it, wxChar ch)
    { return wxStringBase::insert(it, ch); }
  void insert(iterator it, const_iterator first, const_iterator last)
    { wxStringBase::insert(it, first, last); }
  void insert(iterator it, size_type n, wxChar ch)
    { wxStringBase::insert(it, n, ch); }


  wxString& erase(size_type pos = 0, size_type n = npos)
    { return (wxString&)wxStringBase::erase(pos, n); }
  iterator erase(iterator first, iterator last)
    { return wxStringBase::erase(first, last); }
  iterator erase(iterator first)
    { return wxStringBase::erase(first); }






  wxString& replace(size_t nStart, size_t nLen, const wxChar* sz)
    { return (wxString&)wxStringBase::replace(nStart, nLen, sz); }

  wxString& replace(size_t nStart, size_t nLen, const wxString& str)
    { return (wxString&)wxStringBase::replace(nStart, nLen, str); }

  wxString& replace(size_t nStart, size_t nLen, size_t nCount, wxChar ch)
    { return (wxString&)wxStringBase::replace(nStart, nLen, nCount, ch); }

  wxString& replace(size_t nStart, size_t nLen,
                    const wxString& str, size_t nStart2, size_t nLen2)
    { return (wxString&)wxStringBase::replace(nStart, nLen, str,
                                              nStart2, nLen2); }

  wxString& replace(size_t nStart, size_t nLen,
                    const wxChar* sz, size_t nCount)
    { return (wxString&)wxStringBase::replace(nStart, nLen, sz, nCount); }
  wxString& replace(iterator first, iterator last, const_pointer s)
    { return (wxString&)wxStringBase::replace(first, last, s); }
  wxString& replace(iterator first, iterator last, const_pointer s,
                    size_type n)
    { return (wxString&)wxStringBase::replace(first, last, s, n); }
  wxString& replace(iterator first, iterator last, const wxString& s)
    { return (wxString&)wxStringBase::replace(first, last, s); }
  wxString& replace(iterator first, iterator last, size_type n, wxChar c)
    { return (wxString&)wxStringBase::replace(first, last, n, c); }
  wxString& replace(iterator first, iterator last,
                    const_iterator first1, const_iterator last1)
    { return (wxString&)wxStringBase::replace(first, last, first1, last1); }


  wxString& operator+=(const wxString& s)
    { return (wxString&)wxStringBase::operator+=(s); }

  wxString& operator+=(const wxChar *psz)
    { return (wxString&)wxStringBase::operator+=(psz); }

  wxString& operator+=(wxChar ch)
    { return (wxString&)wxStringBase::operator+=(ch); }
};





wxString operator+(const wxString& string1, const wxString& string2);
wxString operator+(const wxString& string, wxChar ch);
wxString operator+(wxChar ch, const wxString& string);
wxString operator+(const wxString& string, const wxChar *psz);
wxString operator+(const wxChar *psz, const wxString& string);
# 1438 "/Development/gefri/build/../libs/wx/include/wx/string.h"
    inline const wxString& wxGetEmptyString()
    {
        return *(wxString *)&wxEmptyString;
    }
# 1503 "/Development/gefri/build/../libs/wx/include/wx/string.h"
class wxStringBuffer
{
public:
    wxStringBuffer(wxString& str, size_t lenWanted = 1024)
        : m_str(str), m_buf(__null)
        { m_buf = m_str.GetWriteBuf(lenWanted); }

    ~wxStringBuffer() { m_str.UngetWriteBuf(); }

    operator wxChar*() const { return m_buf; }

private:
    wxString& m_str;
    wxChar *m_buf;

    private: wxStringBuffer(const wxStringBuffer&); wxStringBuffer& operator=(const wxStringBuffer&);
};

class wxStringBufferLength
{
public:
    wxStringBufferLength(wxString& str, size_t lenWanted = 1024)
        : m_str(str), m_buf(__null), m_len(0), m_lenSet(false)
    {
        m_buf = m_str.GetWriteBuf(lenWanted);
        if ( m_buf != __null ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 1528, __FUNCTION__, L"m_buf != __null", __null);
    }

    ~wxStringBufferLength()
    {
        if ( m_lenSet ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/string.h", 1533, __FUNCTION__, L"m_lenSet", __null);
        m_str.UngetWriteBuf(m_len);
    }

    operator wxChar*() const { return m_buf; }
    void SetLength(size_t length) { m_len = length; m_lenSet = true; }

private:
    wxString& m_str;
    wxChar *m_buf;
    size_t m_len;
    bool m_lenSet;

    private: wxStringBufferLength(const wxStringBufferLength&); wxStringBufferLength& operator=(const wxStringBufferLength&);
};
# 1560 "/Development/gefri/build/../libs/wx/include/wx/string.h"
inline bool operator==(const wxString& s1, const wxString& s2)
    { return (s1.Len() == s2.Len()) && (s1.Cmp(s2) == 0); }
inline bool operator==(const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) == 0; }
inline bool operator==(const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) == 0; }
inline bool operator!=(const wxString& s1, const wxString& s2)
    { return (s1.Len() != s2.Len()) || (s1.Cmp(s2) != 0); }
inline bool operator!=(const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) != 0; }
inline bool operator!=(const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) != 0; }
inline bool operator< (const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) < 0; }
inline bool operator< (const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) < 0; }
inline bool operator< (const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) > 0; }
inline bool operator> (const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) > 0; }
inline bool operator> (const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) > 0; }
inline bool operator> (const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) < 0; }
inline bool operator<=(const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) <= 0; }
inline bool operator<=(const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) <= 0; }
inline bool operator<=(const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) >= 0; }
inline bool operator>=(const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) >= 0; }
inline bool operator>=(const wxString& s1, const wxChar * s2)
    { return s1.Cmp(s2) >= 0; }
inline bool operator>=(const wxChar * s1, const wxString& s2)
    { return s2.Cmp(s1) <= 0; }


inline bool operator==(const wxString& s1, const wxWCharBuffer& s2)
    { return (s1.Cmp((const wchar_t *)s2) == 0); }
inline bool operator==(const wxWCharBuffer& s1, const wxString& s2)
    { return (s2.Cmp((const wchar_t *)s1) == 0); }
inline bool operator!=(const wxString& s1, const wxWCharBuffer& s2)
    { return (s1.Cmp((const wchar_t *)s2) != 0); }
inline bool operator!=(const wxWCharBuffer& s1, const wxString& s2)
    { return (s2.Cmp((const wchar_t *)s1) != 0); }
# 1618 "/Development/gefri/build/../libs/wx/include/wx/string.h"
inline wxString operator+(const wxString& string, const wxWCharBuffer& buf)
    { return string + (const wchar_t *)buf; }
inline wxString operator+(const wxWCharBuffer& buf, const wxString& string)
    { return (const wchar_t *)buf + string; }
# 1633 "/Development/gefri/build/../libs/wx/include/wx/string.h"
inline bool operator==(wxChar c, const wxString& s) { return s.IsSameAs(c); }
inline bool operator==(const wxString& s, wxChar c) { return s.IsSameAs(c); }
inline bool operator!=(wxChar c, const wxString& s) { return !s.IsSameAs(c); }
inline bool operator!=(const wxString& s, wxChar c) { return !s.IsSameAs(c); }
# 17 "/Development/gefri/build/../libs/wx/include/wx/memory.h" 2
# 1 "/Development/gefri/build/../libs/wx/include/wx/msgout.h" 1
# 27 "/Development/gefri/build/../libs/wx/include/wx/msgout.h"
class wxMessageOutput
{
public:
    virtual ~wxMessageOutput() { }


    virtual void Printf(const wxChar* format, ...) = 0;



    static wxMessageOutput* Get();


    static wxMessageOutput* Set(wxMessageOutput* msgout);

private:
    static wxMessageOutput* ms_msgOut;
};







class wxMessageOutputBest : public wxMessageOutput
{
public:
    wxMessageOutputBest() { }

    virtual void Printf(const wxChar* format, ...) ;
};





class wxMessageOutputStderr : public wxMessageOutput
{
public:
    wxMessageOutputStderr() { }

    virtual void Printf(const wxChar* format, ...) ;
};







class wxMessageOutputMessageBox : public wxMessageOutput
{
public:
    wxMessageOutputMessageBox() { }

    virtual void Printf(const wxChar* format, ...) ;
};







class wxMessageOutputDebug : public wxMessageOutput
{
public:
    wxMessageOutputDebug() { }

    virtual void Printf(const wxChar* format, ...) ;
};





class wxMessageOutputLog : public wxMessageOutput
{
public:
    wxMessageOutputLog() { }

    virtual void Printf(const wxChar* format, ...) ;
};
# 18 "/Development/gefri/build/../libs/wx/include/wx/memory.h" 2
# 21 "/Development/gefri/build/../libs/wx/include/wx/object.h" 2

class wxObject;
# 36 "/Development/gefri/build/../libs/wx/include/wx/object.h"
class wxClassInfo;
class wxHashTable;
class wxObjectRefData;





typedef wxObject *(*wxObjectConstructorFn)(void);

class wxClassInfo
{
public:
    wxClassInfo( const wxChar *className,
                 const wxClassInfo *baseInfo1,
                 const wxClassInfo *baseInfo2,
                 int size,
                 wxObjectConstructorFn ctor )
        : m_className(className)
        , m_objectSize(size)
        , m_objectConstructor(ctor)
        , m_baseInfo1(baseInfo1)
        , m_baseInfo2(baseInfo2)
        , m_next(sm_first)
        {
            sm_first = this;
            Register();
        }

    ~wxClassInfo();

    wxObject *CreateObject() const
        { return m_objectConstructor ? (*m_objectConstructor)() : 0; }
    bool IsDynamic() const { return (__null != m_objectConstructor); }

    const wxChar *GetClassName() const { return m_className; }
    const wxChar *GetBaseClassName1() const
        { return m_baseInfo1 ? m_baseInfo1->GetClassName() : __null; }
    const wxChar *GetBaseClassName2() const
        { return m_baseInfo2 ? m_baseInfo2->GetClassName() : __null; }
    const wxClassInfo *GetBaseClass1() const { return m_baseInfo1; }
    const wxClassInfo *GetBaseClass2() const { return m_baseInfo2; }
    int GetSize() const { return m_objectSize; }

    wxObjectConstructorFn GetConstructor() const
        { return m_objectConstructor; }
    static const wxClassInfo *GetFirst() { return sm_first; }
    const wxClassInfo *GetNext() const { return m_next; }
    static wxClassInfo *FindClass(const wxChar *className);




    bool IsKindOf(const wxClassInfo *info) const
    {
        return info != 0 &&
               ( info == this ||
                 ( m_baseInfo1 && m_baseInfo1->IsKindOf(info) ) ||
                 ( m_baseInfo2 && m_baseInfo2->IsKindOf(info) ) );
    }
# 104 "/Development/gefri/build/../libs/wx/include/wx/object.h"
public:
    const wxChar *m_className;
    int m_objectSize;
    wxObjectConstructorFn m_objectConstructor;



    const wxClassInfo *m_baseInfo1;
    const wxClassInfo *m_baseInfo2;




    static wxClassInfo *sm_first;
    wxClassInfo *m_next;



    static wxHashTable *sm_classTable;

private:

    static wxClassInfo *GetBaseByName(const wxChar *name);

    private: wxClassInfo(const wxClassInfo&); wxClassInfo& operator=(const wxClassInfo&);

protected:

    void Register();
    void Unregister();
};

 wxObject *wxCreateDynamicObject(const wxChar *name);
# 312 "/Development/gefri/build/../libs/wx/include/wx/object.h"
inline void* wxCheckCast(void *ptr)
{
    if ( ptr ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/object.h", 314, __FUNCTION__, L"ptr", L"wxStaticCast() used incorrectly");
    return ptr;
}
# 389 "/Development/gefri/build/../libs/wx/include/wx/object.h"
class wxObjectRefData
{
    friend class wxObject;

public:
    wxObjectRefData() : m_count(1) { }
    virtual ~wxObjectRefData() { }

    int GetRefCount() const { return m_count; }

private:
    int m_count;
};





class wxObject
{
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;

public:
    wxObject() { m_refData = __null; }
    virtual ~wxObject() { UnRef(); }

    wxObject(const wxObject& other)
    {
         m_refData = other.m_refData;
         if (m_refData)
             m_refData->m_count++;
    }

    wxObject& operator=(const wxObject& other)
    {
        if ( this != &other )
        {
            Ref(other);
        }
        return *this;
    }

    bool IsKindOf(wxClassInfo *info) const;
# 467 "/Development/gefri/build/../libs/wx/include/wx/object.h"
    wxObjectRefData *GetRefData() const { return m_refData; }
    void SetRefData(wxObjectRefData *data) { m_refData = data; }


    void Ref(const wxObject& clone);


    void UnRef();


    void UnShare() { AllocExclusive(); }


    bool IsSameAs(const wxObject& o) const { return m_refData == o.m_refData; }

protected:



    void AllocExclusive();





    virtual wxObjectRefData *CreateRefData() const;


    virtual wxObjectRefData *CloneRefData(const wxObjectRefData *data) const;

    wxObjectRefData *m_refData;
};

inline wxObject *wxCheckDynamicCast(wxObject *obj, wxClassInfo *classInfo)
{
    return obj && obj->GetClassInfo()->IsKindOf(classInfo) ? obj : __null;
}
# 34 "/Development/gefri/build/../libs/wx/include/wx/list.h" 2
# 52 "/Development/gefri/build/../libs/wx/include/wx/list.h"
extern "C"
{
typedef int (* wxSortCompareFunction)(const void *elem1, const void *elem2);
}

class wxObjectListNode;
typedef wxObjectListNode wxNode;


typedef int (* wxListIterateFunction)(void *current);
# 70 "/Development/gefri/build/../libs/wx/include/wx/list.h"
enum wxKeyType
{
    wxKEY_NONE,
    wxKEY_INTEGER,
    wxKEY_STRING
};
# 385 "/Development/gefri/build/../libs/wx/include/wx/list.h"
union wxListKeyValue
{
    long integer;
    wxChar *string;
};







class wxListKey
{
public:

    wxListKey() : m_keyType(wxKEY_NONE)
        { }
    wxListKey(long i) : m_keyType(wxKEY_INTEGER)
        { m_key.integer = i; }
    wxListKey(const wxChar *s) : m_keyType(wxKEY_STRING)
        { m_key.string = wxStrdupW(s); }
    wxListKey(const wxString& s) : m_keyType(wxKEY_STRING)
        { m_key.string = wxStrdupW(s.c_str()); }


    wxKeyType GetKeyType() const { return m_keyType; }
    const wxChar *GetString() const
        { if ( m_keyType == wxKEY_STRING ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/list.h", 413, __FUNCTION__, L"m_keyType == wxKEY_STRING", __null); return m_key.string; }
    long GetNumber() const
        { if ( m_keyType == wxKEY_INTEGER ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/list.h", 415, __FUNCTION__, L"m_keyType == wxKEY_INTEGER", __null); return m_key.integer; }




    bool operator==(wxListKeyValue value) const ;


    ~wxListKey()
    {
        if ( m_keyType == wxKEY_STRING )
            free(m_key.string);
    }

private:
    wxKeyType m_keyType;
    wxListKeyValue m_key;
};





extern wxListKey wxDefaultListKey;

class wxListBase;

class wxNodeBase
{
friend class wxListBase;
public:

    wxNodeBase(wxListBase *list = (wxListBase *)__null,
               wxNodeBase *previous = (wxNodeBase *)__null,
               wxNodeBase *next = (wxNodeBase *)__null,
               void *data = __null,
               const wxListKey& key = wxDefaultListKey);

    virtual ~wxNodeBase();


    const wxChar *GetKeyString() const { return m_key.string; }
    long GetKeyInteger() const { return m_key.integer; }


    void SetKeyString(wxChar* s) { m_key.string = s; }
    void SetKeyInteger(long i) { m_key.integer = i; }



    wxNode *Next() const __attribute__ ((deprecated));
    wxNode *Previous() const __attribute__ ((deprecated));
    wxObject *Data() const __attribute__ ((deprecated));


protected:

    wxNodeBase *GetNext() const { return m_next; }
    wxNodeBase *GetPrevious() const { return m_previous; }

    void *GetData() const { return m_data; }
    void SetData(void *data) { m_data = data; }


    int IndexOf() const;

    virtual void DeleteData() { }
public:

    void** GetDataPtr() const { return &(((wxNodeBase*)this)->m_data); }
private:

    wxListKeyValue m_key;

    void *m_data;
    wxNodeBase *m_next,
                *m_previous;

    wxListBase *m_list;

    private: wxNodeBase(const wxNodeBase&); wxNodeBase& operator=(const wxNodeBase&);
};





class wxList;

class wxListBase : public wxObject
{
friend class wxNodeBase;
friend class wxHashTableBase;

public:

    wxListBase(wxKeyType keyType = wxKEY_NONE)
        { Init(keyType); }
    virtual ~wxListBase();



    size_t GetCount() const { return m_count; }


    bool IsEmpty() const { return m_count == 0; }




    void Clear();


    void DeleteContents(bool destroy) { m_destroy = destroy; }


    bool GetDeleteContents() const
        { return m_destroy; }


    wxKeyType GetKeyType() const
        { return m_keyType; }


    void SetKeyType(wxKeyType keyType)
        { if ( m_count==0 ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/list.h", 540, __FUNCTION__, L"m_count==0", __null); m_keyType = keyType; }



    int Number() const __attribute__ ((deprecated));
    wxNode *First() const __attribute__ ((deprecated));
    wxNode *Last() const __attribute__ ((deprecated));
    wxNode *Nth(size_t n) const __attribute__ ((deprecated));


    operator wxList&() const __attribute__ ((deprecated));


protected:





    virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next,
                                   void *data,
                                   const wxListKey& key = wxDefaultListKey) = 0;
# 570 "/Development/gefri/build/../libs/wx/include/wx/list.h"
    wxListBase(size_t count, void *elements[]);

    wxListBase(void *object, ... );

protected:
    void Assign(const wxListBase& list)
        { Clear(); DoCopy(list); }


    wxNodeBase *GetFirst() const { return m_nodeFirst; }
    wxNodeBase *GetLast() const { return m_nodeLast; }


    wxNodeBase *Item(size_t index) const;


    void *operator[](size_t n) const
    {
        wxNodeBase *node = Item(n);

        return node ? node->GetData() : (wxNodeBase *)__null;
    }



    wxNodeBase *Prepend(void *object)
        { return (wxNodeBase *)wxListBase::Insert(object); }

    wxNodeBase *Append(void *object);

    wxNodeBase *Insert(void *object) { return Insert( (wxNodeBase*)__null, object); }

    wxNodeBase *Insert(size_t pos, void *object)
        { return pos == GetCount() ? Append(object)
                                   : Insert(Item(pos), object); }

    wxNodeBase *Insert(wxNodeBase *prev, void *object);


    wxNodeBase *Append(long key, void *object);
    wxNodeBase *Append(const wxChar *key, void *object);



    wxNodeBase *DetachNode(wxNodeBase *node);

    bool DeleteNode(wxNodeBase *node);


    bool DeleteObject(void *object);



    wxNodeBase *Find(const void *object) const;


    wxNodeBase *Find(const wxListKey& key) const;


    int IndexOf( void *object ) const;



    void Sort(const wxSortCompareFunction compfunc);


    void *FirstThat(wxListIterateFunction func);
    void ForEach(wxListIterateFunction func);
    void *LastThat(wxListIterateFunction func);



    void Reverse();
    void DeleteNodes(wxNodeBase* first, wxNodeBase* last);
private:


    void Init(wxKeyType keyType = wxKEY_NONE);



    void DoCopy(const wxListBase& list);

    wxNodeBase *AppendCommon(wxNodeBase *node);

    void DoDeleteNode(wxNodeBase *node);

    size_t m_count;
    bool m_destroy;
    wxNodeBase *m_nodeFirst,
               *m_nodeLast;

    wxKeyType m_keyType;
};
# 1162 "/Development/gefri/build/../libs/wx/include/wx/list.h"
inline wxNode *wxNodeBase::Next() const { return (wxNode *)GetNext(); }
inline wxNode *wxNodeBase::Previous() const { return (wxNode *)GetPrevious(); }
inline wxObject *wxNodeBase::Data() const { return (wxObject *)GetData(); }





inline int wxListBase::Number() const { return (int)GetCount(); }
inline wxNode *wxListBase::First() const { return (wxNode *)GetFirst(); }
inline wxNode *wxListBase::Last() const { return (wxNode *)GetLast(); }
inline wxNode *wxListBase::Nth(size_t n) const { return (wxNode *)Item(n); }
inline wxListBase::operator wxList&() const { return *(wxList*)this; }
# 1185 "/Development/gefri/build/../libs/wx/include/wx/list.h"
typedef int (*wxSortFuncFor_wxObjectList)(const wxObject **, const wxObject **); class wxObjectListNode : public wxNodeBase { public: wxObjectListNode(wxListBase *list = (wxListBase *)__null, wxObjectListNode *previous = (wxObjectListNode *)__null, wxObjectListNode *next = (wxObjectListNode *)__null, wxObject *data = (wxObject *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxObjectListNode *GetNext() const { return (wxObjectListNode *)wxNodeBase::GetNext(); } wxObjectListNode *GetPrevious() const { return (wxObjectListNode *)wxNodeBase::GetPrevious(); } wxObject *GetData() const { return (wxObject *)wxNodeBase::GetData(); } void SetData(wxObject *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxObjectListNode(const wxObjectListNode&); wxObjectListNode& operator=(const wxObjectListNode&); }; class wxObjectList : public wxListBase { public: typedef wxObjectListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxObjectList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxObjectList(const wxObjectList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxObjectList(size_t count, wxObject *elements[]) : wxListBase(count, (void **)elements) { } wxObjectList& operator=(const wxObjectList& list) { Assign(list); return *this; } wxObjectListNode *GetFirst() const { return (wxObjectListNode *)wxListBase::GetFirst(); } wxObjectListNode *GetLast() const { return (wxObjectListNode *)wxListBase::GetLast(); } wxObjectListNode *Item(size_t index) const { return (wxObjectListNode *)wxListBase::Item(index); } wxObject *operator[](size_t index) const { wxObjectListNode *node = Item(index); return node ? (wxObject*)(node->GetData()) : (wxObject*)__null; } wxObjectListNode *Append(wxObject *object) { return (wxObjectListNode *)wxListBase::Append(object); } wxObjectListNode *Insert(wxObject *object) { return (wxObjectListNode *)Insert((wxObjectListNode*)__null, object); } wxObjectListNode *Insert(size_t pos, wxObject *object) { return (wxObjectListNode *)wxListBase::Insert(pos, object); } wxObjectListNode *Insert(wxObjectListNode *prev, wxObject *object) { return (wxObjectListNode *)wxListBase::Insert(prev, object); } wxObjectListNode *Append(long key, void *object) { return (wxObjectListNode *)wxListBase::Append(key, object); } wxObjectListNode *Append(const wxChar *key, void *object) { return (wxObjectListNode *)wxListBase::Append(key, object); } wxObjectListNode *DetachNode(wxObjectListNode *node) { return (wxObjectListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxObjectListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxObject *object) { return wxListBase::DeleteObject(object); } void Erase(wxObjectListNode *it) { DeleteNode(it); } wxObjectListNode *Find(const wxObject *object) const { return (wxObjectListNode *)wxListBase::Find(object); } virtual wxObjectListNode *Find(const wxListKey& key) const { return (wxObjectListNode *)wxListBase::Find(key); } int IndexOf(wxObject *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxObjectList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxObjectListNode(this, (wxObjectListNode *)prev, (wxObjectListNode *)next, (wxObject *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxObject* value_type; typedef wxObject* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef iterator itor; typedef wxObject* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef wxObject* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef wxObject* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef wxObject* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxObjectList(size_type n, const_reference v = value_type()) { assign(n, v); } wxObjectList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxObjectList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxObjectList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxObjectList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };


class wxList : public wxObjectList
{
public:




    wxList(int key_type = wxKEY_NONE);



   ~wxList() { }


    wxList& operator=(const wxList& list)
        { (void) wxListBase::operator=(list); return *this; }


    void Sort(wxSortCompareFunction compfunc) { wxListBase::Sort(compfunc); }




    wxNode *Member(wxObject *object) const { return (wxNode *)Find(object); }


private:

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

};






typedef int (*wxSortFuncFor_wxStringListBase)(const wxChar **, const wxChar **); class wxStringListNode : public wxNodeBase { public: wxStringListNode(wxListBase *list = (wxListBase *)__null, wxStringListNode *previous = (wxStringListNode *)__null, wxStringListNode *next = (wxStringListNode *)__null, wxChar *data = (wxChar *)__null, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxStringListNode *GetNext() const { return (wxStringListNode *)wxNodeBase::GetNext(); } wxStringListNode *GetPrevious() const { return (wxStringListNode *)wxNodeBase::GetPrevious(); } wxChar *GetData() const { return (wxChar *)wxNodeBase::GetData(); } void SetData(wxChar *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxStringListNode(const wxStringListNode&); wxStringListNode& operator=(const wxStringListNode&); }; class wxStringListBase : public wxListBase { public: typedef wxStringListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = __null) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxStringListBase(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxStringListBase(const wxStringListBase& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxStringListBase(size_t count, wxChar *elements[]) : wxListBase(count, (void **)elements) { } wxStringListBase& operator=(const wxStringListBase& list) { Assign(list); return *this; } wxStringListNode *GetFirst() const { return (wxStringListNode *)wxListBase::GetFirst(); } wxStringListNode *GetLast() const { return (wxStringListNode *)wxListBase::GetLast(); } wxStringListNode *Item(size_t index) const { return (wxStringListNode *)wxListBase::Item(index); } wxChar *operator[](size_t index) const { wxStringListNode *node = Item(index); return node ? (wxChar*)(node->GetData()) : (wxChar*)__null; } wxStringListNode *Append(wxChar *object) { return (wxStringListNode *)wxListBase::Append(object); } wxStringListNode *Insert(wxChar *object) { return (wxStringListNode *)Insert((wxStringListNode*)__null, object); } wxStringListNode *Insert(size_t pos, wxChar *object) { return (wxStringListNode *)wxListBase::Insert(pos, object); } wxStringListNode *Insert(wxStringListNode *prev, wxChar *object) { return (wxStringListNode *)wxListBase::Insert(prev, object); } wxStringListNode *Append(long key, void *object) { return (wxStringListNode *)wxListBase::Append(key, object); } wxStringListNode *Append(const wxChar *key, void *object) { return (wxStringListNode *)wxListBase::Append(key, object); } wxStringListNode *DetachNode(wxStringListNode *node) { return (wxStringListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxStringListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxChar *object) { return wxListBase::DeleteObject(object); } void Erase(wxStringListNode *it) { DeleteNode(it); } wxStringListNode *Find(const wxChar *object) const { return (wxStringListNode *)wxListBase::Find(object); } virtual wxStringListNode *Find(const wxListKey& key) const { return (wxStringListNode *)wxListBase::Find(key); } int IndexOf(wxChar *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxStringListBase func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxStringListNode(this, (wxStringListNode *)prev, (wxStringListNode *)next, (wxChar *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxChar* value_type; typedef wxChar* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef iterator itor; typedef wxChar* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef wxChar* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(__null), m_init(__null) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef wxChar* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(__null), m_init(__null) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef wxChar* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const ptr_type pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(__null), m_init(__null) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxStringListBase(size_type n, const_reference v = value_type()) { assign(n, v); } wxStringListBase(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(__null, GetLast()); } const_iterator end() const { return const_iterator(__null, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(__null, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(__null, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 2147483647; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v = value_type()) { if ( it == end() ) Append((const_base_reference)v); else Insert(it.m_node, (const_base_reference)v); iterator itprev(it); return itprev--; } void insert(const iterator& it, size_type n, const_reference v = value_type()) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxStringListBase& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxStringListBase& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxStringListBase& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };

class wxStringList : public wxStringListBase
{
public:






    wxStringList();
    wxStringList(const wxChar *first ...);




    wxStringList(const wxStringList& other) : wxStringListBase() { DeleteContents(true); DoCopy(other); }
    wxStringList& operator=(const wxStringList& other)
        { Clear(); DoCopy(other); return *this; }



    wxNode *Add(const wxChar *s);


    wxNode *Prepend(const wxChar *s);

    bool Delete(const wxChar *s);

    wxChar **ListToArray(bool new_copies = false) const;
    bool Member(const wxChar *s) const;


    void Sort();

private:
    void DoCopy(const wxStringList&);

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 21 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h" 2


# 1 "/Development/gefri/build/../libs/wx/include/wx/hashmap.h" 1
# 68 "/Development/gefri/build/../libs/wx/include/wx/hashmap.h"
# 1 "/usr/lib/gcc/i686-apple-darwin10/4.2.1/include/stddef.h" 1 3 4
# 69 "/Development/gefri/build/../libs/wx/include/wx/hashmap.h" 2



struct _wxHashTable_NodeBase
{
    _wxHashTable_NodeBase() : m_nxt(0) {}

    _wxHashTable_NodeBase* m_nxt;




};


class _wxHashTableBase2
{
public:
    typedef void (*NodeDtor)(_wxHashTable_NodeBase*);
    typedef unsigned long (*BucketFromNode)(_wxHashTableBase2*,_wxHashTable_NodeBase*);
    typedef _wxHashTable_NodeBase* (*ProcessNode)(_wxHashTable_NodeBase*);
protected:
    static _wxHashTable_NodeBase* DummyProcessNode(_wxHashTable_NodeBase* node);
    static void DeleteNodes( size_t buckets, _wxHashTable_NodeBase** table,
                             NodeDtor dtor );
    static _wxHashTable_NodeBase* GetFirstNode( size_t buckets,
                                                _wxHashTable_NodeBase** table )
    {
        for( size_t i = 0; i < buckets; ++i )
            if( table[i] )
                return table[i];
        return 0;
    }


    enum { prime_count = 31 };
    static const unsigned long ms_primes[prime_count];


    static unsigned long GetNextPrime( unsigned long n );



    static unsigned long GetPreviousPrime( unsigned long n );

    static void CopyHashTable( _wxHashTable_NodeBase** srcTable,
                               size_t srcBuckets, _wxHashTableBase2* dst,
                               _wxHashTable_NodeBase** dstTable,
                               BucketFromNode func, ProcessNode proc );

    static void** AllocTable( size_t sz )
    {
        return (void **)calloc(sz, sizeof(void*));
    }
    static void FreeTable(void *table)
    {
        free(table);
    }
};
# 461 "/Development/gefri/build/../libs/wx/include/wx/hashmap.h"
inline bool never_grow( size_t, size_t ) { return false; }
inline bool never_shrink( size_t, size_t ) { return false; }
inline bool grow_lf70( size_t buckets, size_t items )
{
    return float(items)/float(buckets) >= 0.85;
}
# 525 "/Development/gefri/build/../libs/wx/include/wx/hashmap.h"
class wxIntegerHash
{
public:
    wxIntegerHash() { }
    unsigned long operator()( long x ) const { return (unsigned long)x; }
    unsigned long operator()( unsigned long x ) const { return x; }
    unsigned long operator()( int x ) const { return (unsigned long)x; }
    unsigned long operator()( unsigned int x ) const { return x; }
    unsigned long operator()( short x ) const { return (unsigned long)x; }
    unsigned long operator()( unsigned short x ) const { return x; }

    unsigned long long operator()( long long x ) const { return static_cast<unsigned long long>(x); }
    unsigned long long operator()( unsigned long long x ) const { return x; }


    wxIntegerHash& operator=(const wxIntegerHash&) { return *this; }
};



class wxIntegerEqual
{
public:
    wxIntegerEqual() { }
    bool operator()( long a, long b ) const { return a == b; }
    bool operator()( unsigned long a, unsigned long b ) const { return a == b; }
    bool operator()( int a, int b ) const { return a == b; }
    bool operator()( unsigned int a, unsigned int b ) const { return a == b; }
    bool operator()( short a, short b ) const { return a == b; }
    bool operator()( unsigned short a, unsigned short b ) const { return a == b; }

    bool operator()( long long a, long long b ) const { return a == b; }
    bool operator()( unsigned long long a, unsigned long long b ) const { return a == b; }


    wxIntegerEqual& operator=(const wxIntegerEqual&) { return *this; }
};


class wxPointerHash
{
public:
    wxPointerHash() { }


    wxUIntPtr operator()( const void* k ) const { return wxPtrToUInt(k); }




    wxPointerHash& operator=(const wxPointerHash&) { return *this; }
};

class wxPointerEqual
{
public:
    wxPointerEqual() { }
    bool operator()( const void* a, const void* b ) const { return a == b; }

    wxPointerEqual& operator=(const wxPointerEqual&) { return *this; }
};


class wxStringHash
{
public:
    wxStringHash() {}
    unsigned long operator()( const wxString& x ) const
        { return wxCharStringHash( x.c_str() ); }
    unsigned long operator()( const wxChar* x ) const
        { return wxCharStringHash( x ); }
    static unsigned long wxCharStringHash( const wxChar* );

    unsigned long operator()( const char* x ) const
        { return charStringHash( x ); }
    static unsigned long charStringHash( const char* );


    wxStringHash& operator=(const wxStringHash&) { return *this; }
};

class wxStringEqual
{
public:
    wxStringEqual() {}
    bool operator()( const wxString& a, const wxString& b ) const
        { return a == b; }
    bool operator()( const wxChar* a, const wxChar* b ) const
        { return wcscmp( a, b ) == 0; }

    bool operator()( const char* a, const char* b ) const
        { return strcmp( a, b ) == 0; }


    wxStringEqual& operator=(const wxStringEqual&) { return *this; }
};
# 735 "/Development/gefri/build/../libs/wx/include/wx/hashmap.h"
class wxLongToLongHashMap_wxImplementation_Pair { public: typedef long t1; typedef long t2; typedef const long const_t1; typedef const long const_t2; wxLongToLongHashMap_wxImplementation_Pair( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; class wxLongToLongHashMap_wxImplementation_KeyEx { typedef long key_type; typedef wxLongToLongHashMap_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxLongToLongHashMap_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxLongToLongHashMap_wxImplementation_KeyEx& operator=(const wxLongToLongHashMap_wxImplementation_KeyEx&) { return *this; } }; class wxLongToLongHashMap_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef long key_type; typedef wxLongToLongHashMap_wxImplementation_Pair value_type; typedef wxIntegerHash hasher; typedef wxIntegerEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const long const_key_type; typedef const wxLongToLongHashMap_wxImplementation_Pair const_mapped_type; public: struct Node; typedef wxLongToLongHashMap_wxImplementation_KeyEx key_extractor; typedef wxLongToLongHashMap_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxLongToLongHashMap_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } wxLongToLongHashMap_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~wxLongToLongHashMap_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxLongToLongHashMap:public wxLongToLongHashMap_wxImplementation_HashTable { public: typedef long mapped_type; class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit wxLongToLongHashMap( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxLongToLongHashMap_wxImplementation_HashTable( hint, hf, eq, wxLongToLongHashMap_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxLongToLongHashMap_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxLongToLongHashMap_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxLongToLongHashMap_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( it->first ); } void erase( const const_iterator& it ) { erase( it->first ); } size_type count( const const_key_type& key ) { return (size_type)(GetNode( key ) ? 1 : 0); } };
# 24 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h" 2
# 1 "/Development/gefri/build/../libs/wx/include/wx/math.h" 1
# 19 "/Development/gefri/build/../libs/wx/include/wx/math.h"
# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4
# 1 "/usr/include/architecture/i386/math.h" 1 3 4
# 36 "/usr/include/architecture/i386/math.h" 3 4
extern "C" {
# 49 "/usr/include/architecture/i386/math.h" 3 4
 typedef float float_t;
 typedef double double_t;
# 108 "/usr/include/architecture/i386/math.h" 3 4
extern unsigned int __math_errhandling ( void );
# 128 "/usr/include/architecture/i386/math.h" 3 4
extern int __fpclassifyf(float );
extern int __fpclassifyd(double );
extern int __fpclassify (long double);
# 163 "/usr/include/architecture/i386/math.h" 3 4
 static __inline__ int __inline_isfinitef (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinited (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinite (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isinff (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinfd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinf (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnanf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnand (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnan (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormalf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormald (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormal (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbit (long double) __attribute__ ((always_inline));

 static __inline__ int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
 static __inline__ int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
 static __inline__ int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
 static __inline__ int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
 static __inline__ int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
 static __inline__ int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
 static __inline__ int __inline_isnanf( float __x ) { return __x != __x; }
 static __inline__ int __inline_isnand( double __x ) { return __x != __x; }
 static __inline__ int __inline_isnan( long double __x ) { return __x != __x; }
 static __inline__ int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
 static __inline__ int __inline_signbitd( double __x ) { union{ double __f; unsigned int __u[2]; }__u; __u.__f = __x; return (int)(__u.__u[1] >> 31); }
 static __inline__ int __inline_signbit( long double __x ){ union{ long double __ld; struct{ unsigned int __m[2]; short __sexp; }__p; }__u; __u.__ld = __x; return (int) (((unsigned short) __u.__p.__sexp) >> 15); }
 static __inline__ int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= 1.17549435e-38F; }
 static __inline__ int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= 2.2250738585072014e-308; }
 static __inline__ int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= 3.36210314311209350626e-4932L; }
# 253 "/usr/include/architecture/i386/math.h" 3 4
extern double acos( double );
extern float acosf( float );

extern double asin( double );
extern float asinf( float );

extern double atan( double );
extern float atanf( float );

extern double atan2( double, double );
extern float atan2f( float, float );

extern double cos( double );
extern float cosf( float );

extern double sin( double );
extern float sinf( float );

extern double tan( double );
extern float tanf( float );

extern double acosh( double );
extern float acoshf( float );

extern double asinh( double );
extern float asinhf( float );

extern double atanh( double );
extern float atanhf( float );

extern double cosh( double );
extern float coshf( float );

extern double sinh( double );
extern float sinhf( float );

extern double tanh( double );
extern float tanhf( float );

extern double exp ( double );
extern float expf ( float );

extern double exp2 ( double );
extern float exp2f ( float );

extern double expm1 ( double );
extern float expm1f ( float );

extern double log ( double );
extern float logf ( float );

extern double log10 ( double );
extern float log10f ( float );

extern double log2 ( double );
extern float log2f ( float );

extern double log1p ( double );
extern float log1pf ( float );

extern double logb ( double );
extern float logbf ( float );

extern double modf ( double, double * );
extern float modff ( float, float * );

extern double ldexp ( double, int );
extern float ldexpf ( float, int );

extern double frexp ( double, int * );
extern float frexpf ( float, int * );

extern int ilogb ( double );
extern int ilogbf ( float );

extern double scalbn ( double, int );
extern float scalbnf ( float, int );

extern double scalbln ( double, long int );
extern float scalblnf ( float, long int );

extern double fabs( double );
extern float fabsf( float );

extern double cbrt( double );
extern float cbrtf( float );

extern double hypot ( double, double );
extern float hypotf ( float, float );

extern double pow ( double, double );
extern float powf ( float, float );

extern double sqrt( double );
extern float sqrtf( float );

extern double erf( double );
extern float erff( float );

extern double erfc( double );
extern float erfcf( float );






extern double lgamma( double );
extern float lgammaf( float );

extern double tgamma( double );
extern float tgammaf( float );

extern double ceil ( double );
extern float ceilf ( float );

extern double floor ( double );
extern float floorf ( float );

extern double nearbyint ( double );
extern float nearbyintf ( float );

extern double rint ( double );
extern float rintf ( float );

extern long int lrint ( double );
extern long int lrintf ( float );

extern double round ( double );
extern float roundf ( float );

extern long int lround ( double );
extern long int lroundf ( float );




    extern long long int llrint ( double );
    extern long long int llrintf ( float );

    extern long long int llround ( double );
    extern long long int llroundf ( float );



extern double trunc ( double );
extern float truncf ( float );

extern double fmod ( double, double );
extern float fmodf ( float, float );

extern double remainder ( double, double );
extern float remainderf ( float, float );

extern double remquo ( double, double, int * );
extern float remquof ( float, float, int * );

extern double copysign ( double, double );
extern float copysignf ( float, float );

extern double nan( const char * );
extern float nanf( const char * );

extern double nextafter ( double, double );
extern float nextafterf ( float, float );

extern double fdim ( double, double );
extern float fdimf ( float, float );

extern double fmax ( double, double );
extern float fmaxf ( float, float );

extern double fmin ( double, double );
extern float fminf ( float, float );

extern double fma ( double, double, double );
extern float fmaf ( float, float, float );

extern long double acosl(long double);
extern long double asinl(long double);
extern long double atanl(long double);
extern long double atan2l(long double, long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
extern long double acoshl(long double);
extern long double asinhl(long double);
extern long double atanhl(long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double tanhl(long double);
extern long double expl(long double);
extern long double exp2l(long double);
extern long double expm1l(long double);
extern long double logl(long double);
extern long double log10l(long double);
extern long double log2l(long double);
extern long double log1pl(long double);
extern long double logbl(long double);
extern long double modfl(long double, long double *);
extern long double ldexpl(long double, int);
extern long double frexpl(long double, int *);
extern int ilogbl(long double);
extern long double scalbnl(long double, int);
extern long double scalblnl(long double, long int);
extern long double fabsl(long double);
extern long double cbrtl(long double);
extern long double hypotl(long double, long double);
extern long double powl(long double, long double);
extern long double sqrtl(long double);
extern long double erfl(long double);
extern long double erfcl(long double);






extern long double lgammal(long double);

extern long double tgammal(long double);
extern long double ceill(long double);
extern long double floorl(long double);
extern long double nearbyintl(long double);
extern long double rintl(long double);
extern long int lrintl(long double);
extern long double roundl(long double);
extern long int lroundl(long double);



    extern long long int llrintl(long double);
    extern long long int llroundl(long double);


extern long double truncl(long double);
extern long double fmodl(long double, long double);
extern long double remainderl(long double, long double);
extern long double remquol(long double, long double, int *);
extern long double copysignl(long double, long double);
extern long double nanl(const char *);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern long double fdiml(long double, long double);
extern long double fmaxl(long double, long double);
extern long double fminl(long double, long double);
extern long double fmal(long double, long double, long double);
# 510 "/usr/include/architecture/i386/math.h" 3 4
extern double __inf( void );
extern float __inff( void );
extern long double __infl( void );
extern float __nan( void );


extern double j0 ( double );

extern double j1 ( double );

extern double jn ( int, double );

extern double y0 ( double );

extern double y1 ( double );

extern double yn ( int, double );

extern double scalb ( double, double );
# 546 "/usr/include/architecture/i386/math.h" 3 4
extern int signgam;
# 560 "/usr/include/architecture/i386/math.h" 3 4
extern long int rinttol ( double );

extern long int roundtol ( double );
# 600 "/usr/include/architecture/i386/math.h" 3 4
extern int finite ( double );

extern double gamma ( double );
# 613 "/usr/include/architecture/i386/math.h" 3 4
extern double significand ( double );




extern double drem ( double, double );
# 639 "/usr/include/architecture/i386/math.h" 3 4
}
# 29 "/usr/include/math.h" 2 3 4
# 20 "/Development/gefri/build/../libs/wx/include/wx/math.h" 2
# 102 "/Development/gefri/build/../libs/wx/include/wx/math.h"
        inline bool wxIsSameDouble(double x, double y) { return x == y; }



    inline bool wxIsNullDouble(double x) { return wxIsSameDouble(x, 0.); }

    inline int wxRound(double x)
    {

            return int(round(x));



    }
# 129 "/Development/gefri/build/../libs/wx/include/wx/math.h"
    extern "C" {


    wxFloat64 ConvertFromIeeeExtended(const wxInt8 *bytes);
    void ConvertToIeeeExtended(wxFloat64 num, wxInt8 *bytes);

    }
# 25 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h" 2





class wxBitmap;
class wxBrush;
class wxColour;
class wxCursor;
class wxFont;
class wxIcon;
class wxPalette;
class wxPen;
class wxRegion;
class wxString;






enum wxBitmapType
{
    wxBITMAP_TYPE_INVALID,
    wxBITMAP_TYPE_BMP,
    wxBITMAP_TYPE_BMP_RESOURCE,
    wxBITMAP_TYPE_RESOURCE = wxBITMAP_TYPE_BMP_RESOURCE,
    wxBITMAP_TYPE_ICO,
    wxBITMAP_TYPE_ICO_RESOURCE,
    wxBITMAP_TYPE_CUR,
    wxBITMAP_TYPE_CUR_RESOURCE,
    wxBITMAP_TYPE_XBM,
    wxBITMAP_TYPE_XBM_DATA,
    wxBITMAP_TYPE_XPM,
    wxBITMAP_TYPE_XPM_DATA,
    wxBITMAP_TYPE_TIF,
    wxBITMAP_TYPE_TIF_RESOURCE,
    wxBITMAP_TYPE_GIF,
    wxBITMAP_TYPE_GIF_RESOURCE,
    wxBITMAP_TYPE_PNG,
    wxBITMAP_TYPE_PNG_RESOURCE,
    wxBITMAP_TYPE_JPEG,
    wxBITMAP_TYPE_JPEG_RESOURCE,
    wxBITMAP_TYPE_PNM,
    wxBITMAP_TYPE_PNM_RESOURCE,
    wxBITMAP_TYPE_PCX,
    wxBITMAP_TYPE_PCX_RESOURCE,
    wxBITMAP_TYPE_PICT,
    wxBITMAP_TYPE_PICT_RESOURCE,
    wxBITMAP_TYPE_ICON,
    wxBITMAP_TYPE_ICON_RESOURCE,
    wxBITMAP_TYPE_ANI,
    wxBITMAP_TYPE_IFF,
    wxBITMAP_TYPE_TGA,
    wxBITMAP_TYPE_MACCURSOR,
    wxBITMAP_TYPE_MACCURSOR_RESOURCE,
    wxBITMAP_TYPE_ANY = 50
};


enum wxStockCursor
{
    wxCURSOR_NONE,
    wxCURSOR_ARROW,
    wxCURSOR_RIGHT_ARROW,
    wxCURSOR_BULLSEYE,
    wxCURSOR_CHAR,
    wxCURSOR_CROSS,
    wxCURSOR_HAND,
    wxCURSOR_IBEAM,
    wxCURSOR_LEFT_BUTTON,
    wxCURSOR_MAGNIFIER,
    wxCURSOR_MIDDLE_BUTTON,
    wxCURSOR_NO_ENTRY,
    wxCURSOR_PAINT_BRUSH,
    wxCURSOR_PENCIL,
    wxCURSOR_POINT_LEFT,
    wxCURSOR_POINT_RIGHT,
    wxCURSOR_QUESTION_ARROW,
    wxCURSOR_RIGHT_BUTTON,
    wxCURSOR_SIZENESW,
    wxCURSOR_SIZENS,
    wxCURSOR_SIZENWSE,
    wxCURSOR_SIZEWE,
    wxCURSOR_SIZING,
    wxCURSOR_SPRAYCAN,
    wxCURSOR_WAIT,
    wxCURSOR_WATCH,
    wxCURSOR_BLANK,




    wxCURSOR_COPY_ARROW ,
# 128 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h"
    wxCURSOR_ARROWWAIT,

    wxCURSOR_MAX
};
# 207 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h"
class wxSize
{
public:

    int x, y;


    wxSize() : x(0), y(0) { }
    wxSize(int xx, int yy) : x(xx), y(yy) { }



    bool operator==(const wxSize& sz) const { return x == sz.x && y == sz.y; }
    bool operator!=(const wxSize& sz) const { return x != sz.x || y != sz.y; }

    wxSize operator+(const wxSize& sz) const { return wxSize(x + sz.x, y + sz.y); }
    wxSize operator-(const wxSize& sz) const { return wxSize(x - sz.x, y - sz.y); }
    wxSize operator/(int i) const { return wxSize(x / i, y / i); }
    wxSize operator*(int i) const { return wxSize(x * i, y * i); }

    wxSize& operator+=(const wxSize& sz) { x += sz.x; y += sz.y; return *this; }
    wxSize& operator-=(const wxSize& sz) { x -= sz.x; y -= sz.y; return *this; }
    wxSize& operator/=(const int i) { x /= i; y /= i; return *this; }
    wxSize& operator*=(const int i) { x *= i; y *= i; return *this; }

    void IncTo(const wxSize& sz)
        { if ( sz.x > x ) x = sz.x; if ( sz.y > y ) y = sz.y; }
    void DecTo(const wxSize& sz)
        { if ( sz.x < x ) x = sz.x; if ( sz.y < y ) y = sz.y; }

    void IncBy(int dx, int dy) { x += dx; y += dy; }
    void IncBy(const wxSize& sz) { IncBy(sz.x, sz.y); }
    void IncBy(int d) { IncBy(d, d); }

    void DecBy(int dx, int dy) { IncBy(-dx, -dy); }
    void DecBy(const wxSize& sz) { DecBy(sz.x, sz.y); }
    void DecBy(int d) { DecBy(d, d); }


    wxSize& Scale(float xscale, float yscale)
        { x = (int)(x*xscale); y = (int)(y*yscale); return *this; }


    void Set(int xx, int yy) { x = xx; y = yy; }
    void SetWidth(int w) { x = w; }
    void SetHeight(int h) { y = h; }

    int GetWidth() const { return x; }
    int GetHeight() const { return y; }

    bool IsFullySpecified() const { return x != wxDefaultCoord && y != wxDefaultCoord; }



    void SetDefaults(const wxSize& size)
    {
        if ( x == wxDefaultCoord )
            x = size.x;
        if ( y == wxDefaultCoord )
            y = size.y;
    }


    int GetX() const { return x; }
    int GetY() const { return y; }
};





class wxRealPoint
{
public:
    double x;
    double y;

    wxRealPoint() : x(0.0), y(0.0) { }
    wxRealPoint(double xx, double yy) : x(xx), y(yy) { }

    wxRealPoint operator+(const wxRealPoint& pt) const { return wxRealPoint(x + pt.x, y + pt.y); }
    wxRealPoint operator-(const wxRealPoint& pt) const { return wxRealPoint(x - pt.x, y - pt.y); }

    bool operator==(const wxRealPoint& pt) const
    {
        return wxIsSameDouble(x, pt.x) && wxIsSameDouble(y, pt.y);
    }
    bool operator!=(const wxRealPoint& pt) const { return !(*this == pt); }
};


class wxPoint
{
public:
    int x, y;

    wxPoint() : x(0), y(0) { }
    wxPoint(int xx, int yy) : x(xx), y(yy) { }




    bool operator==(const wxPoint& p) const { return x == p.x && y == p.y; }
    bool operator!=(const wxPoint& p) const { return !(*this == p); }


    wxPoint operator+(const wxPoint& p) const { return wxPoint(x + p.x, y + p.y); }
    wxPoint operator-(const wxPoint& p) const { return wxPoint(x - p.x, y - p.y); }

    wxPoint& operator+=(const wxPoint& p) { x += p.x; y += p.y; return *this; }
    wxPoint& operator-=(const wxPoint& p) { x -= p.x; y -= p.y; return *this; }

    wxPoint& operator+=(const wxSize& s) { x += s.GetWidth(); y += s.GetHeight(); return *this; }
    wxPoint& operator-=(const wxSize& s) { x -= s.GetWidth(); y -= s.GetHeight(); return *this; }

    wxPoint operator+(const wxSize& s) const { return wxPoint(x + s.GetWidth(), y + s.GetHeight()); }
    wxPoint operator-(const wxSize& s) const { return wxPoint(x - s.GetWidth(), y - s.GetHeight()); }

    wxPoint operator-() const { return wxPoint(-x, -y); }
};





class wxRect
{
public:
    wxRect()
        : x(0), y(0), width(0), height(0)
        { }
    wxRect(int xx, int yy, int ww, int hh)
        : x(xx), y(yy), width(ww), height(hh)
        { }
    wxRect(const wxPoint& topLeft, const wxPoint& bottomRight);
    wxRect(const wxPoint& pt, const wxSize& size)
        : x(pt.x), y(pt.y), width(size.x), height(size.y)
        { }
    wxRect(const wxSize& size)
        : x(0), y(0), width(size.x), height(size.y)
        { }



    int GetX() const { return x; }
    void SetX(int xx) { x = xx; }

    int GetY() const { return y; }
    void SetY(int yy) { y = yy; }

    int GetWidth() const { return width; }
    void SetWidth(int w) { width = w; }

    int GetHeight() const { return height; }
    void SetHeight(int h) { height = h; }

    wxPoint GetPosition() const { return wxPoint(x, y); }
    void SetPosition( const wxPoint &p ) { x = p.x; y = p.y; }

    wxSize GetSize() const { return wxSize(width, height); }
    void SetSize( const wxSize &s ) { width = s.GetWidth(); height = s.GetHeight(); }

    bool IsEmpty() const { return (width <= 0) || (height <= 0); }

    int GetLeft() const { return x; }
    int GetTop() const { return y; }
    int GetBottom() const { return y + height - 1; }
    int GetRight() const { return x + width - 1; }

    void SetLeft(int left) { x = left; }
    void SetRight(int right) { width = right - x + 1; }
    void SetTop(int top) { y = top; }
    void SetBottom(int bottom) { height = bottom - y + 1; }

    wxPoint GetTopLeft() const { return GetPosition(); }
    wxPoint GetLeftTop() const { return GetTopLeft(); }
    void SetTopLeft(const wxPoint &p) { SetPosition(p); }
    void SetLeftTop(const wxPoint &p) { SetTopLeft(p); }

    wxPoint GetBottomRight() const { return wxPoint(GetRight(), GetBottom()); }
    wxPoint GetRightBottom() const { return GetBottomRight(); }
    void SetBottomRight(const wxPoint &p) { SetRight(p.x); SetBottom(p.y); }
    void SetRightBottom(const wxPoint &p) { SetBottomRight(p); }

    wxPoint GetTopRight() const { return wxPoint(GetRight(), GetTop()); }
    wxPoint GetRightTop() const { return GetTopRight(); }
    void SetTopRight(const wxPoint &p) { SetRight(p.x); SetTop(p.y); }
    void SetRightTop(const wxPoint &p) { SetTopLeft(p); }

    wxPoint GetBottomLeft() const { return wxPoint(GetLeft(), GetBottom()); }
    wxPoint GetLeftBottom() const { return GetBottomLeft(); }
    void SetBottomLeft(const wxPoint &p) { SetLeft(p.x); SetBottom(p.y); }
    void SetLeftBottom(const wxPoint &p) { SetBottomLeft(p); }


    wxRect& Inflate(wxCoord dx, wxCoord dy);
    wxRect& Inflate(const wxSize& d) { return Inflate(d.x, d.y); }
    wxRect& Inflate(wxCoord d) { return Inflate(d, d); }
    wxRect Inflate(wxCoord dx, wxCoord dy) const
    {
        wxRect r = *this;
        r.Inflate(dx, dy);
        return r;
    }

    wxRect& Deflate(wxCoord dx, wxCoord dy) { return Inflate(-dx, -dy); }
    wxRect& Deflate(const wxSize& d) { return Inflate(-d.x, -d.y); }
    wxRect& Deflate(wxCoord d) { return Inflate(-d); }
    wxRect Deflate(wxCoord dx, wxCoord dy) const
    {
        wxRect r = *this;
        r.Deflate(dx, dy);
        return r;
    }

    void Offset(wxCoord dx, wxCoord dy) { x += dx; y += dy; }
    void Offset(const wxPoint& pt) { Offset(pt.x, pt.y); }

    wxRect& Intersect(const wxRect& rect);
    wxRect Intersect(const wxRect& rect) const
    {
        wxRect r = *this;
        r.Intersect(rect);
        return r;
    }

    wxRect& Union(const wxRect& rect);
    wxRect Union(const wxRect& rect) const
    {
        wxRect r = *this;
        r.Union(rect);
        return r;
    }


    bool operator==(const wxRect& rect) const;
    bool operator!=(const wxRect& rect) const { return !(*this == rect); }


    bool Contains(int x, int y) const;
    bool Contains(const wxPoint& pt) const { return Contains(pt.x, pt.y); }

    bool Contains(const wxRect& rect) const;



    bool Inside(int x, int y) const __attribute__ ((deprecated));
    bool Inside(const wxPoint& pt) const __attribute__ ((deprecated));
    bool Inside(const wxRect& rect) const __attribute__ ((deprecated));



    bool Intersects(const wxRect& rect) const;



    wxRect operator+(const wxRect& rect) const;
    wxRect& operator+=(const wxRect& rect)
    {
        *this = *this + rect;
        return *this;
    }




    wxRect CentreIn(const wxRect& r, int dir = wxBOTH) const
    {
        return wxRect(dir & wxHORIZONTAL ? r.x + (r.width - width)/2 : x,
                      dir & wxVERTICAL ? r.y + (r.height - height)/2 : y,
                      width, height);
    }

    wxRect CenterIn(const wxRect& r, int dir = wxBOTH) const
    {
        return CentreIn(r, dir);
    }

public:
    int x, y, width, height;
};


inline bool wxRect::Inside(int cx, int cy) const { return Contains(cx, cy); }
inline bool wxRect::Inside(const wxPoint& pt) const { return Contains(pt); }
inline bool wxRect::Inside(const wxRect& rect) const { return Contains(rect); }







typedef wxInt8 wxDash;

class wxGDIObjListBase {
public:
    wxGDIObjListBase();
    ~wxGDIObjListBase();

protected:
    wxList list;
};

class wxPenList: public wxGDIObjListBase
{
public:
    wxPen *FindOrCreatePen(const wxColour& colour, int width, int style);

    void AddPen(wxPen*) __attribute__ ((deprecated));
    void RemovePen(wxPen*) __attribute__ ((deprecated));

};

class wxBrushList: public wxGDIObjListBase
{
public:
    wxBrush *FindOrCreateBrush(const wxColour& colour, int style = wxSOLID);

    void AddBrush(wxBrush*) __attribute__ ((deprecated));
    void RemoveBrush(wxBrush*) __attribute__ ((deprecated));

};

class wxFontList: public wxGDIObjListBase
{
public:
    wxFont *FindOrCreateFont(int pointSize, int family, int style, int weight,
                             bool underline = false,
                             const wxString& face = wxEmptyString,
                             wxFontEncoding encoding = wxFONTENCODING_DEFAULT);

    void AddFont(wxFont*) __attribute__ ((deprecated));
    void RemoveFont(wxFont*) __attribute__ ((deprecated));

};

class wxStringToColourHashMap_wxImplementation_Pair { public: typedef wxString t1; typedef wxColour* t2; typedef const wxString const_t1; typedef const wxColour* const_t2; wxStringToColourHashMap_wxImplementation_Pair( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; class wxStringToColourHashMap_wxImplementation_KeyEx { typedef wxString key_type; typedef wxStringToColourHashMap_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxStringToColourHashMap_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxStringToColourHashMap_wxImplementation_KeyEx& operator=(const wxStringToColourHashMap_wxImplementation_KeyEx&) { return *this; } }; class wxStringToColourHashMap_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef wxStringToColourHashMap_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const wxStringToColourHashMap_wxImplementation_Pair const_mapped_type; public: struct Node; typedef wxStringToColourHashMap_wxImplementation_KeyEx key_extractor; typedef wxStringToColourHashMap_wxImplementation_HashTable Self; protected: Node** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* m_next() { return (Node*)this->m_nxt; } value_type m_value; }; class Iterator; friend class Iterator; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete (Node*)node; } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(0), m_ht(0) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht((Self*)ht) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return m_ht->m_table[i]; } return 0; } void PlusPlus() { Node* next = m_node->m_next(); m_node = next ? next : GetNextNode(); } }; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator( node, (Self*)ht ) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxStringToColourHashMap_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (Node**)AllocTable( m_tableBuckets ); } wxStringToColourHashMap_wxImplementation_HashTable( const Self& ht ) : m_table( 0 ), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); return *this; } ~wxStringToColourHashMap_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes( m_tableBuckets, (_wxHashTable_NodeBase**)m_table, DeleteNode ); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator( 0, this ); } iterator end() { return iterator( 0, this ); } const_iterator begin() const { return const_iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } iterator begin() { return iterator( (Node*)GetFirstNode( m_tableBuckets, (_wxHashTable_NodeBase**)m_table ), this ); } size_type erase( const const_key_type& key ) { Node** node = GetNodePtr( key ); if( !node ) return 0; --m_items; Node* temp = (*node)->m_next(); delete *node; (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->m_next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_nxt = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } Node** GetNodePtr( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node** node = &m_table[bucket]; while( *node ) { if( m_equals( m_getKey( (*node)->m_value ), key ) ) return node; node = (Node**)&(*node)->m_nxt; } return __null; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = m_table[bucket]; while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->m_next(); } return 0; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); Node** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (Node**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( (_wxHashTable_NodeBase**)srcTable, srcBuckets, this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( (_wxHashTable_NodeBase**)ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, (_wxHashTable_NodeBase**)m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxStringToColourHashMap:public wxStringToColourHashMap_wxImplementation_HashTable { public: typedef wxColour* mapped_type; class Insert_Result { public: typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result( const const_t1& f, const const_t2& s ):first(t1(f)),second(t2(s)) {} t1 first; t2 second; }; explicit wxStringToColourHashMap( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxStringToColourHashMap_wxImplementation_HashTable( hint, hf, eq, wxStringToColourHashMap_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxStringToColourHashMap_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxStringToColourHashMap_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxStringToColourHashMap_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( it->first ); } void erase( const const_iterator& it ) { erase( it->first ); } size_type count( const const_key_type& key ) { return (size_type)(GetNode( key ) ? 1 : 0); } };

class wxColourDatabase
{
public:
    wxColourDatabase();
    ~wxColourDatabase();


    wxColour Find(const wxString& name) const;
    wxString FindName(const wxColour& colour) const;


    void AddColour(const wxString& name, const wxColour& colour);



    wxColour *FindColour(const wxString& name) __attribute__ ((deprecated));
# 571 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h"
private:


    void Initialize();

    wxStringToColourHashMap *m_map;
};

class wxResourceCache: public wxList
{
public:
    wxResourceCache() { }

    wxResourceCache(const unsigned int keyType) : wxList(keyType) { }

    virtual ~wxResourceCache();
};






extern wxPenList* wxThePenList;
extern wxBrushList* wxTheBrushList;
extern wxFontList* wxTheFontList;
# 608 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h"
class wxStockGDI
{
public:
    enum Item {
        BRUSH_BLACK,
        BRUSH_BLUE,
        BRUSH_CYAN,
        BRUSH_GREEN,
        BRUSH_GREY,
        BRUSH_LIGHTGREY,
        BRUSH_MEDIUMGREY,
        BRUSH_RED,
        BRUSH_TRANSPARENT,
        BRUSH_WHITE,
        COLOUR_BLACK,
        COLOUR_BLUE,
        COLOUR_CYAN,
        COLOUR_GREEN,
        COLOUR_LIGHTGREY,
        COLOUR_RED,
        COLOUR_WHITE,
        CURSOR_CROSS,
        CURSOR_HOURGLASS,
        CURSOR_STANDARD,
        FONT_ITALIC,
        FONT_NORMAL,
        FONT_SMALL,
        FONT_SWISS,
        PEN_BLACK,
        PEN_BLACKDASHED,
        PEN_CYAN,
        PEN_GREEN,
        PEN_GREY,
        PEN_LIGHTGREY,
        PEN_MEDIUMGREY,
        PEN_RED,
        PEN_TRANSPARENT,
        PEN_WHITE,
        ITEMCOUNT
    };

    wxStockGDI();
    virtual ~wxStockGDI();
    static void DeleteAll();

    static wxStockGDI& instance() { return *ms_instance; }

    static const wxBrush* GetBrush(Item item);
    static const wxColour* GetColour(Item item);
    static const wxCursor* GetCursor(Item item);

    virtual const wxFont* GetFont(Item item);
    static const wxPen* GetPen(Item item);

protected:
    static wxStockGDI* ms_instance;

    static wxObject* ms_stockObject[ITEMCOUNT];

    private: wxStockGDI(const wxStockGDI&); wxStockGDI& operator=(const wxStockGDI&);
};
# 710 "/Development/gefri/build/../libs/wx/include/wx/gdicmn.h"
extern wxBitmap wxNullBitmap;
extern wxIcon wxNullIcon;
extern wxCursor wxNullCursor;
extern wxPen wxNullPen;
extern wxBrush wxNullBrush;
extern wxPalette wxNullPalette;
extern wxFont wxNullFont;
extern wxColour wxNullColour;

extern wxColourDatabase* wxTheColourDatabase;

extern const wxChar wxPanelNameStr[];

extern const wxSize wxDefaultSize;
extern const wxPoint wxDefaultPosition;






extern void wxInitializeStockLists();
extern void wxDeleteStockLists();


extern bool wxColourDisplay();


extern int wxDisplayDepth();



extern void wxDisplaySize(int *width, int *height);
extern wxSize wxGetDisplaySize();
extern void wxDisplaySizeMM(int *width, int *height);
extern wxSize wxGetDisplaySizeMM();


extern void wxClientDisplayRect(int *x, int *y, int *width, int *height);
extern wxRect wxGetClientDisplayRect();


extern void wxSetCursor(const wxCursor& cursor);
# 5 "../../src/adapters/wx/gxRect.h" 2




class gxRect: public wxRect {
public:
  gxRect()
    : wxRect() {}
  gxRect(int xx, int yy, int ww, int hh)
    : wxRect(xx, yy, ww, hh) {}
  gxRect(wxRect aRect)
    :wxRect(aRect) {}
};
# 12 "../../src/core/gxRect.h" 2
# 5 "../../src/lightweights/gxViewElement.h" 2
# 1 "../../src/core/gxComposite.h" 1



# 1 "../../src/core/gxObject.h" 1



# 1 "../../src/adapters/wx/gxObject.h" 1



# 1 "/Development/gefri/build/../libs/wx/include/wx/object.h" 1
# 5 "../../src/adapters/wx/gxObject.h" 2




class gxObject: public wxObject {};
# 5 "../../src/core/gxObject.h" 2
# 5 "../../src/core/gxComposite.h" 2
# 1 "/Development/gefri/build/../libs/wx/include/wx/log.h" 1
# 40 "/Development/gefri/build/../libs/wx/include/wx/log.h"
typedef unsigned long wxTraceMask;
typedef unsigned long wxLogLevel;
# 51 "/Development/gefri/build/../libs/wx/include/wx/log.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/arrstr.h" 1
# 18 "/Development/gefri/build/../libs/wx/include/wx/arrstr.h"
 int wxStringSortAscending(wxString*, wxString*);
 int wxStringSortDescending(wxString*, wxString*);
# 98 "/Development/gefri/build/../libs/wx/include/wx/arrstr.h"
class wxArrayString
{
public:

  typedef int ( *CompareFunction)(const wxString& first,
                                 const wxString& second);


  typedef int ( *CompareFunction2)(wxString* first,
                                  wxString* second);



  wxArrayString() { Init(false); }
# 120 "/Development/gefri/build/../libs/wx/include/wx/arrstr.h"
  wxArrayString(int autoSort) { Init(autoSort != 0); }

  wxArrayString(size_t sz, const wxChar** a);

  wxArrayString(size_t sz, const wxString* a);

  wxArrayString(const wxArrayString& array);

  wxArrayString& operator=(const wxArrayString& src);

 ~wxArrayString();



  void Empty();

  void Clear();

  void Alloc(size_t nCount);

  void Shrink();



  size_t GetCount() const { return m_nCount; }

  bool IsEmpty() const { return m_nCount == 0; }

  size_t Count() const { return m_nCount; }



  wxString& Item(size_t nIndex) const
    {
        if ( nIndex < m_nCount ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/arrstr.h", 155, __FUNCTION__, L"nIndex < m_nCount", L"wxArrayString: index out of bounds");


        return *(wxString *)&(m_pItems[nIndex]);
    }


  wxString& operator[](size_t nIndex) const { return Item(nIndex); }

  wxString& Last() const
  {
      if ( !IsEmpty() ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/arrstr.h", 166, __FUNCTION__, L"!IsEmpty()", L"wxArrayString: index out of bounds");

      return Item(Count() - 1);
  }
# 183 "/Development/gefri/build/../libs/wx/include/wx/arrstr.h"
  int Index (const wxChar *sz, bool bCase = true, bool bFromEnd = false) const;


  size_t Add(const wxString& str, size_t nInsert = 1);

  void Insert(const wxString& str, size_t uiIndex, size_t nInsert = 1);

  void SetCount(size_t count);

  void Remove(const wxChar *sz);




  void RemoveAt(size_t nIndex, size_t nRemove = 1);




  void Sort(bool reverseOrder = false);

  void Sort(CompareFunction compareFunction);
  void Sort(CompareFunction2 compareFunction);



  bool operator==(const wxArrayString& a) const;

  bool operator!=(const wxArrayString& a) const { return !(*this == a); }


  typedef wxString value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef int difference_type;
  typedef size_t size_type;


  class reverse_iterator
  {
    typedef wxString value_type;
    typedef value_type* pointer;
    typedef value_type& reference;
    typedef reverse_iterator itor;
    friend itor operator+(int o, const itor& it);
    friend itor operator+(const itor& it, int o);
    friend itor operator-(const itor& it, int o);
    friend difference_type operator -(const itor& i1, const itor& i2);
  public:
    pointer m_ptr;
    reverse_iterator() : m_ptr(__null) { }
    reverse_iterator(pointer ptr) : m_ptr(ptr) { }
    reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { }
    reference operator*() const { return *m_ptr; }
    pointer operator->() const { return m_ptr; }
    itor& operator++() { --m_ptr; return *this; }
    const itor operator++(int)
      { reverse_iterator tmp = *this; --m_ptr; return tmp; }
    itor& operator--() { ++m_ptr; return *this; }
    const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; }
    bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; }
    bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; }
  };

  class const_reverse_iterator
  {
    typedef wxString value_type;
    typedef const value_type* pointer;
    typedef const value_type& reference;
    typedef const_reverse_iterator itor;
    friend itor operator+(int o, const itor& it);
    friend itor operator+(const itor& it, int o);
    friend itor operator-(const itor& it, int o);
    friend difference_type operator -(const itor& i1, const itor& i2);
  public:
    pointer m_ptr;
    const_reverse_iterator() : m_ptr(__null) { }
    const_reverse_iterator(pointer ptr) : m_ptr(ptr) { }
    const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { }
    const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { }
    reference operator*() const { return *m_ptr; }
    pointer operator->() const { return m_ptr; }
    itor& operator++() { --m_ptr; return *this; }
    const itor operator++(int)
      { itor tmp = *this; --m_ptr; return tmp; }
    itor& operator--() { ++m_ptr; return *this; }
    const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; }
    bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; }
    bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; }
  };

  wxArrayString(const_iterator first, const_iterator last)
    { Init(false); assign(first, last); }
  wxArrayString(size_type n, const_reference v) { Init(false); assign(n, v); }
  void assign(const_iterator first, const_iterator last);
  void assign(size_type n, const_reference v)
    { clear(); Add(v, n); }
  reference back() { return *(end() - 1); }
  const_reference back() const { return *(end() - 1); }
  iterator begin() { return (wxString *)&(m_pItems[0]); }
  const_iterator begin() const { return (wxString *)&(m_pItems[0]); }
  size_type capacity() const { return m_nSize; }
  void clear() { Clear(); }
  bool empty() const { return IsEmpty(); }
  iterator end() { return begin() + GetCount(); }
  const_iterator end() const { return begin() + GetCount(); }
  iterator erase(iterator first, iterator last)
  {
      size_t idx = first - begin();
      RemoveAt(idx, last - first);
      return begin() + idx;
  }
  iterator erase(iterator it) { return erase(it, it + 1); }
  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  void insert(iterator it, size_type n, const_reference v)
    { Insert(v, it - begin(), n); }
  iterator insert(iterator it, const_reference v = value_type())
    { size_t idx = it - begin(); Insert(v, idx); return begin() + idx; }
  void insert(iterator it, const_iterator first, const_iterator last);
  size_type max_size() const { return 2147483647; }
  void pop_back() { RemoveAt(GetCount() - 1); }
  void push_back(const_reference v) { Add(v); }
  reverse_iterator rbegin() { return reverse_iterator(end() - 1); }
  const_reverse_iterator rbegin() const;
  reverse_iterator rend() { return reverse_iterator(begin() - 1); }
  const_reverse_iterator rend() const;
  void reserve(size_type n) ;
  void resize(size_type n, value_type v = value_type());
  size_type size() const { return GetCount(); }

protected:
  void Init(bool autoSort);
  void Copy(const wxArrayString& src);

private:
  void Grow(size_t nIncrement = 0);
  void Free();

  void DoSort();

  size_t m_nSize,
          m_nCount;

  wxChar **m_pItems;

  bool m_autoSort;
};

class wxSortedArrayString : public wxArrayString
{
public:
  wxSortedArrayString() : wxArrayString(true)
    { }
  wxSortedArrayString(const wxArrayString& array) : wxArrayString(true)
    { Copy(array); }
};





class wxCArrayString
{
public:
    wxCArrayString( const wxArrayString& array )
        : m_array( array ), m_strings( __null )
    { }
    ~wxCArrayString() { delete[] m_strings; }

    size_t GetCount() const { return m_array.GetCount(); }
    wxString* GetStrings()
    {
        if( m_strings ) return m_strings;
        size_t count = m_array.GetCount();
        m_strings = new wxString[count];
        for( size_t i = 0; i < count; ++i )
            m_strings[i] = m_array[i];
        return m_strings;
    }


    wxString* Release();


private:
    const wxArrayString& m_array;
    wxString* m_strings;
};
# 52 "/Development/gefri/build/../libs/wx/include/wx/log.h" 2





# 1 "/Development/gefri/build/../libs/wx/include/wx/dynarray.h" 1
# 67 "/Development/gefri/build/../libs/wx/include/wx/dynarray.h"
extern "C"
{
typedef int ( *CMPFUNC)(const void* pItem1, const void* pItem2);
}
# 809 "/Development/gefri/build/../libs/wx/include/wx/dynarray.h"
typedef const void * _wxArraywxBaseArrayPtrVoid; class wxBaseArrayPtrVoid { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayPtrVoid(); wxBaseArrayPtrVoid(const wxBaseArrayPtrVoid& array); wxBaseArrayPtrVoid& operator=(const wxBaseArrayPtrVoid& src); ~wxBaseArrayPtrVoid(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayPtrVoid defval = _wxArraywxBaseArrayPtrVoid()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayPtrVoid base_type; protected: _wxArraywxBaseArrayPtrVoid& Item(size_t uiIndex) const { if ( uiIndex < m_nCount ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 810, __FUNCTION__, L"uiIndex < m_nCount", __null); return m_pItems[uiIndex]; } _wxArraywxBaseArrayPtrVoid& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayPtrVoid lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayPtrVoid lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayPtrVoid lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayPtrVoid lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayPtrVoid lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayPtrVoid lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayPtrVoid lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayPtrVoid value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayPtrVoid *m_pItems; };

typedef char _wxArraywxBaseArrayChar; class wxBaseArrayChar { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayChar(); wxBaseArrayChar(const wxBaseArrayChar& array); wxBaseArrayChar& operator=(const wxBaseArrayChar& src); ~wxBaseArrayChar(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayChar defval = _wxArraywxBaseArrayChar()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayChar base_type; protected: _wxArraywxBaseArrayChar& Item(size_t uiIndex) const { if ( uiIndex < m_nCount ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 811, __FUNCTION__, L"uiIndex < m_nCount", __null); return m_pItems[uiIndex]; } _wxArraywxBaseArrayChar& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayChar lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayChar lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayChar lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayChar lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayChar lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayChar lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayChar lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayChar value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayChar *m_pItems; };
typedef short _wxArraywxBaseArrayShort; class wxBaseArrayShort { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayShort(); wxBaseArrayShort(const wxBaseArrayShort& array); wxBaseArrayShort& operator=(const wxBaseArrayShort& src); ~wxBaseArrayShort(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayShort defval = _wxArraywxBaseArrayShort()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayShort base_type; protected: _wxArraywxBaseArrayShort& Item(size_t uiIndex) const { if ( uiIndex < m_nCount ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 812, __FUNCTION__, L"uiIndex < m_nCount", __null); return m_pItems[uiIndex]; } _wxArraywxBaseArrayShort& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayShort lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayShort lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayShort lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayShort lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayShort lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayShort lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayShort lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayShort value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayShort *m_pItems; };
typedef int _wxArraywxBaseArrayInt; class wxBaseArrayInt { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayInt(); wxBaseArrayInt(const wxBaseArrayInt& array); wxBaseArrayInt& operator=(const wxBaseArrayInt& src); ~wxBaseArrayInt(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayInt defval = _wxArraywxBaseArrayInt()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayInt base_type; protected: _wxArraywxBaseArrayInt& Item(size_t uiIndex) const { if ( uiIndex < m_nCount ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 813, __FUNCTION__, L"uiIndex < m_nCount", __null); return m_pItems[uiIndex]; } _wxArraywxBaseArrayInt& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayInt lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayInt lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayInt lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayInt lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayInt lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayInt lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayInt lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayInt value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayInt *m_pItems; };
typedef long _wxArraywxBaseArrayLong; class wxBaseArrayLong { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayLong(); wxBaseArrayLong(const wxBaseArrayLong& array); wxBaseArrayLong& operator=(const wxBaseArrayLong& src); ~wxBaseArrayLong(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayLong defval = _wxArraywxBaseArrayLong()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayLong base_type; protected: _wxArraywxBaseArrayLong& Item(size_t uiIndex) const { if ( uiIndex < m_nCount ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 814, __FUNCTION__, L"uiIndex < m_nCount", __null); return m_pItems[uiIndex]; } _wxArraywxBaseArrayLong& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayLong lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayLong lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayLong lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayLong lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayLong lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayLong lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayLong lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayLong value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayLong *m_pItems; };
typedef size_t _wxArraywxBaseArraySizeT; class wxBaseArraySizeT { typedef CMPFUNC SCMPFUNC; public: wxBaseArraySizeT(); wxBaseArraySizeT(const wxBaseArraySizeT& array); wxBaseArraySizeT& operator=(const wxBaseArraySizeT& src); ~wxBaseArraySizeT(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArraySizeT defval = _wxArraywxBaseArraySizeT()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArraySizeT base_type; protected: _wxArraywxBaseArraySizeT& Item(size_t uiIndex) const { if ( uiIndex < m_nCount ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 815, __FUNCTION__, L"uiIndex < m_nCount", __null); return m_pItems[uiIndex]; } _wxArraywxBaseArraySizeT& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArraySizeT lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArraySizeT lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArraySizeT lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArraySizeT lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArraySizeT lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArraySizeT lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArraySizeT lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArraySizeT value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArraySizeT *m_pItems; };
typedef double _wxArraywxBaseArrayDouble; class wxBaseArrayDouble { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayDouble(); wxBaseArrayDouble(const wxBaseArrayDouble& array); wxBaseArrayDouble& operator=(const wxBaseArrayDouble& src); ~wxBaseArrayDouble(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayDouble defval = _wxArraywxBaseArrayDouble()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayDouble base_type; protected: _wxArraywxBaseArrayDouble& Item(size_t uiIndex) const { if ( uiIndex < m_nCount ) ; else wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 816, __FUNCTION__, L"uiIndex < m_nCount", __null); return m_pItems[uiIndex]; } _wxArraywxBaseArrayDouble& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayDouble lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayDouble lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayDouble lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayDouble lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayDouble lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayDouble lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayDouble lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayDouble value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef int difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type n, value_type v = value_type()) { SetCount(n, v); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 2147483647; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayDouble *m_pItems; };
# 993 "/Development/gefri/build/../libs/wx/include/wx/dynarray.h"
typedef short _wxArraywxArrayShort; struct wxAssert_wxArrayShort { unsigned int TypeTooBigToBeStoredInwxBaseArrayShort: sizeof(_wxArraywxArrayShort) <= sizeof(wxBaseArrayShort::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayShort)(_wxArraywxArrayShort *pItem1, _wxArraywxArrayShort *pItem2); class wxArrayShort : public wxBaseArrayShort { public: wxArrayShort() { } ~wxArrayShort() { } wxArrayShort& operator=(const wxArrayShort& src) { wxBaseArrayShort* temp = (wxBaseArrayShort*) this; (*temp) = ((const wxBaseArrayShort&)src); return *this; } _wxArraywxArrayShort& operator[](size_t uiIndex) const { return (_wxArraywxArrayShort&)(wxBaseArrayShort::operator[](uiIndex)); } _wxArraywxArrayShort& Item(size_t uiIndex) const { return (_wxArraywxArrayShort&)(wxBaseArrayShort::operator[](uiIndex)); } _wxArraywxArrayShort& Last() const { return (_wxArraywxArrayShort&)(wxBaseArrayShort::operator[](Count() - 1)); } int Index(_wxArraywxArrayShort lItem, bool bFromEnd = false) const { return wxBaseArrayShort::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayShort lItem, size_t nInsert = 1) { wxBaseArrayShort::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayShort lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayShort::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayShort::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayShort lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 993, __FUNCTION__, L"iIndex != wxNOT_FOUND", L"removing inexisting element in wxArray::Remove"); return; } typedef int wxDummyCheckInt; wxBaseArrayShort::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayShort fCmp) { wxBaseArrayShort::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayShort::iterator biterator; typedef wxBaseArrayShort::const_iterator bconst_iterator; typedef wxBaseArrayShort::value_type bvalue_type; typedef wxBaseArrayShort::const_reference bconst_reference; public: typedef _wxArraywxArrayShort value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayShort::difference_type difference_type; typedef wxBaseArrayShort::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayShort value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayShort value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayShort(size_type n, const_reference v) { assign(n, v); } wxArrayShort(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayShort::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayShort::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayShort::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayShort::begin(); } size_type capacity() const { return wxBaseArrayShort::capacity(); } iterator end() { return (iterator)wxBaseArrayShort::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayShort::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayShort::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayShort::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayShort::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayShort::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayShort::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayShort::pop_back(); } void push_back(const_reference v) { wxBaseArrayShort::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayShort::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayShort::resize(n, v); } };
typedef int _wxArraywxArrayInt; struct wxAssert_wxArrayInt { unsigned int TypeTooBigToBeStoredInwxBaseArrayInt: sizeof(_wxArraywxArrayInt) <= sizeof(wxBaseArrayInt::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayInt)(_wxArraywxArrayInt *pItem1, _wxArraywxArrayInt *pItem2); class wxArrayInt : public wxBaseArrayInt { public: wxArrayInt() { } ~wxArrayInt() { } wxArrayInt& operator=(const wxArrayInt& src) { wxBaseArrayInt* temp = (wxBaseArrayInt*) this; (*temp) = ((const wxBaseArrayInt&)src); return *this; } _wxArraywxArrayInt& operator[](size_t uiIndex) const { return (_wxArraywxArrayInt&)(wxBaseArrayInt::operator[](uiIndex)); } _wxArraywxArrayInt& Item(size_t uiIndex) const { return (_wxArraywxArrayInt&)(wxBaseArrayInt::operator[](uiIndex)); } _wxArraywxArrayInt& Last() const { return (_wxArraywxArrayInt&)(wxBaseArrayInt::operator[](Count() - 1)); } int Index(_wxArraywxArrayInt lItem, bool bFromEnd = false) const { return wxBaseArrayInt::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayInt lItem, size_t nInsert = 1) { wxBaseArrayInt::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayInt lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayInt::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayInt::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayInt lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 994, __FUNCTION__, L"iIndex != wxNOT_FOUND", L"removing inexisting element in wxArray::Remove"); return; } typedef int wxDummyCheckInt; wxBaseArrayInt::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayInt fCmp) { wxBaseArrayInt::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayInt::iterator biterator; typedef wxBaseArrayInt::const_iterator bconst_iterator; typedef wxBaseArrayInt::value_type bvalue_type; typedef wxBaseArrayInt::const_reference bconst_reference; public: typedef _wxArraywxArrayInt value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayInt::difference_type difference_type; typedef wxBaseArrayInt::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayInt value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayInt value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayInt(size_type n, const_reference v) { assign(n, v); } wxArrayInt(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayInt::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayInt::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayInt::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayInt::begin(); } size_type capacity() const { return wxBaseArrayInt::capacity(); } iterator end() { return (iterator)wxBaseArrayInt::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayInt::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayInt::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayInt::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayInt::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayInt::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayInt::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayInt::pop_back(); } void push_back(const_reference v) { wxBaseArrayInt::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayInt::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayInt::resize(n, v); } };
typedef double _wxArraywxArrayDouble; struct wxAssert_wxArrayDouble { unsigned int TypeTooBigToBeStoredInwxBaseArrayDouble: sizeof(_wxArraywxArrayDouble) <= sizeof(wxBaseArrayDouble::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayDouble)(_wxArraywxArrayDouble *pItem1, _wxArraywxArrayDouble *pItem2); class wxArrayDouble : public wxBaseArrayDouble { public: wxArrayDouble() { } ~wxArrayDouble() { } wxArrayDouble& operator=(const wxArrayDouble& src) { wxBaseArrayDouble* temp = (wxBaseArrayDouble*) this; (*temp) = ((const wxBaseArrayDouble&)src); return *this; } _wxArraywxArrayDouble& operator[](size_t uiIndex) const { return (_wxArraywxArrayDouble&)(wxBaseArrayDouble::operator[](uiIndex)); } _wxArraywxArrayDouble& Item(size_t uiIndex) const { return (_wxArraywxArrayDouble&)(wxBaseArrayDouble::operator[](uiIndex)); } _wxArraywxArrayDouble& Last() const { return (_wxArraywxArrayDouble&)(wxBaseArrayDouble::operator[](Count() - 1)); } int Index(_wxArraywxArrayDouble lItem, bool bFromEnd = false) const { return wxBaseArrayDouble::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayDouble lItem, size_t nInsert = 1) { wxBaseArrayDouble::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayDouble lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayDouble::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayDouble::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayDouble lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 995, __FUNCTION__, L"iIndex != wxNOT_FOUND", L"removing inexisting element in wxArray::Remove"); return; } typedef int wxDummyCheckInt; wxBaseArrayDouble::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayDouble fCmp) { wxBaseArrayDouble::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayDouble::iterator biterator; typedef wxBaseArrayDouble::const_iterator bconst_iterator; typedef wxBaseArrayDouble::value_type bvalue_type; typedef wxBaseArrayDouble::const_reference bconst_reference; public: typedef _wxArraywxArrayDouble value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayDouble::difference_type difference_type; typedef wxBaseArrayDouble::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayDouble value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayDouble value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayDouble(size_type n, const_reference v) { assign(n, v); } wxArrayDouble(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayDouble::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayDouble::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayDouble::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayDouble::begin(); } size_type capacity() const { return wxBaseArrayDouble::capacity(); } iterator end() { return (iterator)wxBaseArrayDouble::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayDouble::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayDouble::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayDouble::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayDouble::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayDouble::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayDouble::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayDouble::pop_back(); } void push_back(const_reference v) { wxBaseArrayDouble::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayDouble::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayDouble::resize(n, v); } };
typedef long _wxArraywxArrayLong; struct wxAssert_wxArrayLong { unsigned int TypeTooBigToBeStoredInwxBaseArrayLong: sizeof(_wxArraywxArrayLong) <= sizeof(wxBaseArrayLong::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayLong)(_wxArraywxArrayLong *pItem1, _wxArraywxArrayLong *pItem2); class wxArrayLong : public wxBaseArrayLong { public: wxArrayLong() { } ~wxArrayLong() { } wxArrayLong& operator=(const wxArrayLong& src) { wxBaseArrayLong* temp = (wxBaseArrayLong*) this; (*temp) = ((const wxBaseArrayLong&)src); return *this; } _wxArraywxArrayLong& operator[](size_t uiIndex) const { return (_wxArraywxArrayLong&)(wxBaseArrayLong::operator[](uiIndex)); } _wxArraywxArrayLong& Item(size_t uiIndex) const { return (_wxArraywxArrayLong&)(wxBaseArrayLong::operator[](uiIndex)); } _wxArraywxArrayLong& Last() const { return (_wxArraywxArrayLong&)(wxBaseArrayLong::operator[](Count() - 1)); } int Index(_wxArraywxArrayLong lItem, bool bFromEnd = false) const { return wxBaseArrayLong::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayLong lItem, size_t nInsert = 1) { wxBaseArrayLong::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayLong lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayLong::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayLong::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayLong lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 996, __FUNCTION__, L"iIndex != wxNOT_FOUND", L"removing inexisting element in wxArray::Remove"); return; } typedef int wxDummyCheckInt; wxBaseArrayLong::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayLong fCmp) { wxBaseArrayLong::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayLong::iterator biterator; typedef wxBaseArrayLong::const_iterator bconst_iterator; typedef wxBaseArrayLong::value_type bvalue_type; typedef wxBaseArrayLong::const_reference bconst_reference; public: typedef _wxArraywxArrayLong value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayLong::difference_type difference_type; typedef wxBaseArrayLong::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayLong value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayLong value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayLong(size_type n, const_reference v) { assign(n, v); } wxArrayLong(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayLong::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayLong::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayLong::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayLong::begin(); } size_type capacity() const { return wxBaseArrayLong::capacity(); } iterator end() { return (iterator)wxBaseArrayLong::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayLong::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayLong::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayLong::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayLong::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayLong::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayLong::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayLong::pop_back(); } void push_back(const_reference v) { wxBaseArrayLong::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayLong::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayLong::resize(n, v); } };
typedef void * _wxArraywxArrayPtrVoid; struct wxAssert_wxArrayPtrVoid { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxArrayPtrVoid) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayPtrVoid)(_wxArraywxArrayPtrVoid *pItem1, _wxArraywxArrayPtrVoid *pItem2); class wxArrayPtrVoid : public wxBaseArrayPtrVoid { public: wxArrayPtrVoid() { } ~wxArrayPtrVoid() { } wxArrayPtrVoid& operator=(const wxArrayPtrVoid& src) { wxBaseArrayPtrVoid* temp = (wxBaseArrayPtrVoid*) this; (*temp) = ((const wxBaseArrayPtrVoid&)src); return *this; } _wxArraywxArrayPtrVoid& operator[](size_t uiIndex) const { return (_wxArraywxArrayPtrVoid&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayPtrVoid& Item(size_t uiIndex) const { return (_wxArraywxArrayPtrVoid&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayPtrVoid& Last() const { return (_wxArraywxArrayPtrVoid&)(wxBaseArrayPtrVoid::operator[](Count() - 1)); } int Index(_wxArraywxArrayPtrVoid lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayPtrVoid lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayPtrVoid lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayPtrVoid lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) ; else { wxOnAssert(L"/Development/gefri/build/../libs/wx/include/wx/dynarray.h", 997, __FUNCTION__, L"iIndex != wxNOT_FOUND", L"removing inexisting element in wxArray::Remove"); return; } typedef int wxDummyCheckInt; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayPtrVoid fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxArrayPtrVoid value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayPtrVoid value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(__null) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayPtrVoid value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(__null) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayPtrVoid(size_type n, const_reference v) { assign(n, v); } wxArrayPtrVoid(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } };
# 58 "/Development/gefri/build/../libs/wx/include/wx/log.h" 2
# 72 "/Development/gefri/build/../libs/wx/include/wx/log.h"
    class wxTextCtrl;
    class wxLogFrame;
    class wxFrame;
    class wxWindow;







enum
{
    wxLOG_FatalError,
    wxLOG_Error,
    wxLOG_Warning,
    wxLOG_Message,
    wxLOG_Status,
    wxLOG_Info,
    wxLOG_Debug,
    wxLOG_Trace,
    wxLOG_Progress,
    wxLOG_User = 100,
    wxLOG_Max = 10000
};
# 111 "/Development/gefri/build/../libs/wx/include/wx/log.h"
# 1 "/Development/gefri/build/../libs/wx/include/wx/iosfwrap.h" 1
# 112 "/Development/gefri/build/../libs/wx/include/wx/log.h" 2






class wxLog
{
public:

    wxLog(){}




    static bool IsEnabled() { return ms_doLog; }


    static bool EnableLogging(bool doIt = true)
        { bool doLogOld = ms_doLog; ms_doLog = doIt; return doLogOld; }



    static void OnLog(wxLogLevel level, const wxChar *szString, time_t t);






    virtual void Flush();


    static void FlushActive()
    {
        if ( !ms_suspendCount )
        {
            wxLog *log = GetActiveTarget();
            if ( log )
                log->Flush();
        }
    }




    static wxLog *GetActiveTarget();


    static wxLog *SetActiveTarget(wxLog *pLogger);




    static void Suspend() { ms_suspendCount++; }


    static void Resume() { ms_suspendCount--; }




    static void SetVerbose(bool bVerbose = true) { ms_bVerbose = bVerbose; }


    static void SetLogLevel(wxLogLevel logLevel) { ms_logLevel = logLevel; }




    static void DontCreateOnDemand();



    static void DoCreateOnDemand();



    static void SetRepetitionCounting(bool bRepetCounting = true)
        { ms_bRepetCounting = bRepetCounting; }


    static bool GetRepetitionCounting() { return ms_bRepetCounting; }


    static void SetTraceMask(wxTraceMask ulMask) { ms_ulTraceMask = ulMask; }


    static void AddTraceMask(const wxString& str)
        { ms_aTraceMasks.push_back(str); }


    static void RemoveTraceMask(const wxString& str);


    static void ClearTraceMasks();


    static const wxArrayString &GetTraceMasks() { return ms_aTraceMasks; }




    static void SetTimestamp(const wxChar *ts) { ms_timestamp = ts; }





    static bool GetVerbose() { return ms_bVerbose; }


    static wxTraceMask GetTraceMask() { return ms_ulTraceMask; }


    static bool IsAllowedTraceMask(const wxChar *mask);


    static wxLogLevel GetLogLevel() { return ms_logLevel; }


    static const wxChar *GetTimestamp() { return ms_timestamp; }






    static void TimeStamp(wxString *str);


    virtual ~wxLog();



    bool HasPendingMessages() const { return true; }



    static wxChar *SetLogBuffer(wxChar *buf, size_t size = 0) __attribute__ ((deprecated));


protected:




    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);



    virtual void DoLogString(const wxChar *szString, time_t t);



    static unsigned DoLogNumberOfRepeats();

private:




    static bool ms_bRepetCounting;
    static wxString ms_prevString;

    static unsigned ms_prevCounter;
    static time_t ms_prevTimeStamp;
    static wxLogLevel ms_prevLevel;

    static wxLog *ms_pLogger;
    static bool ms_doLog;
    static bool ms_bAutoCreate;
    static bool ms_bVerbose;

    static wxLogLevel ms_logLevel;

    static size_t ms_suspendCount;



    static const wxChar *ms_timestamp;

    static wxTraceMask ms_ulTraceMask;
    static wxArrayString ms_aTraceMasks;




    unsigned LogLastRepeatIfNeeded();



    unsigned LogLastRepeatIfNeededUnlocked();
};






class wxLogBuffer : public wxLog
{
public:
    wxLogBuffer() { }


    const wxString& GetBuffer() const { return m_str; }



    virtual void Flush();

protected:
    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);
    virtual void DoLogString(const wxChar *szString, time_t t);

private:
    wxString m_str;

    private: wxLogBuffer(const wxLogBuffer&); wxLogBuffer& operator=(const wxLogBuffer&);
};



class wxLogStderr : public wxLog
{
public:

    wxLogStderr(FILE *fp = (FILE *) __null);

protected:

    virtual void DoLogString(const wxChar *szString, time_t t);

    FILE *m_fp;

    private: wxLogStderr(const wxLogStderr&); wxLogStderr& operator=(const wxLogStderr&);
};
# 390 "/Development/gefri/build/../libs/wx/include/wx/log.h"
class wxLogNull
{
public:
    wxLogNull() : m_flagOld(wxLog::EnableLogging(false)) { }
    ~wxLogNull() { (void)wxLog::EnableLogging(m_flagOld); }

private:
    bool m_flagOld;
};
# 409 "/Development/gefri/build/../libs/wx/include/wx/log.h"
class wxLogChain : public wxLog
{
public:
    wxLogChain(wxLog *logger);
    virtual ~wxLogChain();


    void SetLog(wxLog *logger);



    void PassMessages(bool bDoPass) { m_bPassMessages = bDoPass; }


    bool IsPassingMessages() const { return m_bPassMessages; }


    wxLog *GetOldLog() const { return m_logOld; }


    virtual void Flush();



    void DetachOldLog() { m_logOld = __null; }


protected:

    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);

private:

    wxLog *m_logNew;


    wxLog *m_logOld;


    bool m_bPassMessages;

    private: wxLogChain(const wxLogChain&); wxLogChain& operator=(const wxLogChain&);
};


class wxLogPassThrough : public wxLogChain
{
public:
    wxLogPassThrough();

private:
    private: wxLogPassThrough(const wxLogPassThrough&); wxLogPassThrough& operator=(const wxLogPassThrough&);
};



# 1 "/Development/gefri/build/../libs/wx/include/wx/generic/logg.h" 1
# 26 "/Development/gefri/build/../libs/wx/include/wx/generic/logg.h"
class wxLogTextCtrl : public wxLog
{
public:
    wxLogTextCtrl(wxTextCtrl *pTextCtrl);

protected:

    virtual void DoLogString(const wxChar *szString, time_t t);

private:

    wxTextCtrl *m_pTextCtrl;

    private: wxLogTextCtrl(const wxLogTextCtrl&); wxLogTextCtrl& operator=(const wxLogTextCtrl&);
};
# 50 "/Development/gefri/build/../libs/wx/include/wx/generic/logg.h"
class wxLogGui : public wxLog
{
public:

    wxLogGui();


    virtual void Flush();

protected:
    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);


    void Clear();

    wxArrayString m_aMessages;
    wxArrayInt m_aSeverity;
    wxArrayLong m_aTimes;
    bool m_bErrors,
                  m_bWarnings,
                  m_bHasMessages;

};
# 85 "/Development/gefri/build/../libs/wx/include/wx/generic/logg.h"
class wxLogWindow : public wxLogPassThrough
{
public:
    wxLogWindow(wxWindow *pParent,
                const wxChar *szTitle,
                bool bShow = true,
                bool bPassToOld = true);

    virtual ~wxLogWindow();



    void Show(bool bShow = true);

    wxFrame *GetFrame() const;




    virtual void OnFrameCreate(wxFrame *frame);




    virtual bool OnFrameClose(wxFrame *frame);


    virtual void OnFrameDelete(wxFrame *frame);

protected:
    virtual void DoLog(wxLogLevel level, const wxChar *szString, time_t t);
    virtual void DoLogString(const wxChar *szString, time_t t);

private:
    wxLogFrame *m_pLogFrame;

    private: wxLogWindow(const wxLogWindow&); wxLogWindow& operator=(const wxLogWindow&);
};
# 466 "/Development/gefri/build/../libs/wx/include/wx/log.h" 2
# 482 "/Development/gefri/build/../libs/wx/include/wx/log.h"
 unsigned long wxSysErrorCode();


 const wxChar* wxSysErrorMsg(unsigned long nErrCode = 0);
# 540 "/Development/gefri/build/../libs/wx/include/wx/log.h"
extern void wxVLogGeneric(wxLogLevel level, const wxChar *szFormat, va_list argptr); extern void wxLogGeneric(wxLogLevel level, const wxChar *szFormat, ...) ;


extern void wxVLogFatalError(const wxChar *szFormat, va_list argptr); extern void wxLogFatalError(const wxChar *szFormat, ...) ;
extern void wxVLogError(const wxChar *szFormat, va_list argptr); extern void wxLogError(const wxChar *szFormat, ...) ;
extern void wxVLogWarning(const wxChar *szFormat, va_list argptr); extern void wxLogWarning(const wxChar *szFormat, ...) ;
extern void wxVLogMessage(const wxChar *szFormat, va_list argptr); extern void wxLogMessage(const wxChar *szFormat, ...) ;
extern void wxVLogInfo(const wxChar *szFormat, va_list argptr); extern void wxLogInfo(const wxChar *szFormat, ...) ;
extern void wxVLogVerbose(const wxChar *szFormat, va_list argptr); extern void wxLogVerbose(const wxChar *szFormat, ...) ;



extern void wxVLogStatus(const wxChar *szFormat, va_list argptr); extern void wxLogStatus(const wxChar *szFormat, ...) ;



    class wxFrame;

    extern void wxVLogStatus(wxFrame * pFrame, const wxChar *szFormat, va_list argptr); extern void wxLogStatus(wxFrame * pFrame, const wxChar *szFormat, ...) ;




extern void wxVLogSysError(const wxChar *szFormat, va_list argptr); extern void wxLogSysError(const wxChar *szFormat, ...) ;



extern void wxVLogSysError(long lErrCode, const wxChar *szFormat, va_list argptr); extern void wxLogSysError(long lErrCode, const wxChar *szFormat, ...) ;



    extern void wxVLogDebug(const wxChar *szFormat, va_list argptr); extern void wxLogDebug(const wxChar *szFormat, ...) ;







    extern void wxVLogTrace(const wxChar * mask, const wxChar *szFormat, va_list argptr); extern void wxLogTrace(const wxChar * mask, const wxChar *szFormat, ...) ;




    extern void wxVLogTrace(wxTraceMask mask, const wxChar *szFormat, va_list argptr); extern void wxLogTrace(wxTraceMask mask, const wxChar *szFormat, ...) ;
# 617 "/Development/gefri/build/../libs/wx/include/wx/log.h"
void
wxSafeShowMessage(const wxString& title, const wxString& text);
# 6 "../../src/core/gxComposite.h" 2

# 1 "/usr/include/c++/4.2.1/list" 1 3
# 63 "/usr/include/c++/4.2.1/list" 3
       
# 64 "/usr/include/c++/4.2.1/list" 3






# 1 "/usr/include/c++/4.2.1/bits/stl_list.h" 1 3
# 67 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
namespace std {







  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;

    static void
    swap(_List_node_base& __x, _List_node_base& __y);

    void
    transfer(_List_node_base * const __first,
      _List_node_base * const __last);

    void
    reverse();

    void
    hook(_List_node_base * const __position);

    void
    unhook();
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
    {
      _Tp _M_data;
    };
# 111 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      _List_node_base* _M_node;
    };
# 188 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const _List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }







  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 298 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 _List_node_base _M_node;

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }


      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 406 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;
# 449 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     _M_get_Tp_allocator().construct(&__p->_M_data, __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }

    public:





      explicit
      list(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
# 482 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_fill_initialize(__n, __value); }
# 495 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 508 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 533 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 546 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 562 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }






      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 677 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type());






      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 732 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 748 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 762 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 777 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 792 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 807 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, _M_get_Node_allocator());
 splice(__position, __tmp);
      }
# 827 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, _M_get_Node_allocator());
   splice(__position, __tmp);
 }
# 851 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 872 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 889 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      swap(list& __x)
      {
 _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 925 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x)
      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
# 945 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x, iterator __i)
      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }
# 971 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x, iterator __first, iterator __last)
      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }
# 994 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1008 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1022 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      unique();
# 1037 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1050 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      merge(list& __x);
# 1065 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);






      void
      reverse()
      { this->_M_impl._M_node.reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:



      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_fill_initialize(static_cast<size_type>(__n),
        static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n > 0; --__n)
   push_back(__x);
      }





      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->transfer(__first._M_node, __last._M_node); }


      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->hook(__position._M_node);
      }


      void
      _M_erase(iterator __position)
      {
        __position._M_node->unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
        _M_get_Tp_allocator().destroy(&__n->_M_data);
        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (_M_get_Node_allocator() != __x._M_get_Node_allocator())
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
# 1194 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1223 "/usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

}
# 71 "/usr/include/c++/4.2.1/list" 2 3


# 1 "/usr/include/c++/4.2.1/bits/list.tcc" 1 3
# 65 "/usr/include/c++/4.2.1/bits/list.tcc" 3
namespace std {

  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);
   _M_get_Tp_allocator().destroy(&__tmp->_M_data);
   _M_put_node(__tmp);
 }
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     _M_erase(__first);
   __first = __next;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    merge(list& __x)
    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      merge(list& __x, _StrictWeakOrdering __comp)
      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }

}
# 74 "/usr/include/c++/4.2.1/list" 2 3
# 8 "../../src/core/gxComposite.h" 2


class gxComposite;

typedef std::list< gxComposite* > Children;
typedef Children::iterator ChildIterator;
# 40 "../../src/core/gxComposite.h"
class gxComposite: public gxObject
{
public:
  gxComposite();
  ~gxComposite();





  void AddChild(gxComposite* aChild);






  void RemoveChild(gxComposite* aChild, bool aAndDelete = false);





  void RemoveAllChildren(bool aAndDelete = false);







  void SetParent(gxComposite* aParent, bool aAndRemoveFromParent = true);




  gxComposite* GetParent() { return mParent; }





  Children GetChildren() { return mChildren; }
protected:







  virtual void OnAddChild(gxComposite* aChild) {}







  virtual void OnRemoveChild(gxComposite* aChild) {}







  gxComposite* Child(ChildIterator it) { return (*it); }


  Children mChildren;

  gxComposite* mParent;
};
# 6 "../../src/lightweights/gxViewElement.h" 2
# 1 "../../src/lightweights/gxPainter.h" 1



# 1 "../../src/core/gxObject.h" 1
# 5 "../../src/lightweights/gxPainter.h" 2


# 1 "/usr/include/c++/4.2.1/stack" 1 3
# 63 "/usr/include/c++/4.2.1/stack" 3
       
# 64 "/usr/include/c++/4.2.1/stack" 3





# 1 "/usr/include/c++/4.2.1/deque" 1 3
# 63 "/usr/include/c++/4.2.1/deque" 3
       
# 64 "/usr/include/c++/4.2.1/deque" 3






# 1 "/usr/include/c++/4.2.1/bits/stl_deque.h" 1 3
# 69 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
namespace std {
# 83 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return __size < 512 ? size_t(512 / __size) : size_t(1); }
# 101 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) {}

      _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) {}

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }







      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value);
# 370 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }

      ~_Deque_base();

    protected:



      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 478 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 628 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;






      using _Base::_M_impl;

    public:





      explicit
      deque(const allocator_type& __a = allocator_type())
      : _Base(__a, 0) {}
# 693 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 706 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 726 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }






      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 751 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 764 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 780 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }



      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 886 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start + difference_type(__new_size));
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }





      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 916 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 931 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
# 956 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 974 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1031 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
# 1052 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
# 1073 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1094 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1116 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1128 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1142 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1165 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
# 1184 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1196 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(begin()); }

    protected:



      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(__n);
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1257 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1281 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);





      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }







      void _M_push_back_aux(const value_type&);

      void _M_push_front_aux(const value_type&);

      void _M_pop_back_aux();

      void _M_pop_front_aux();






      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);


      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);

      void
      _M_destroy_data_dispatch(iterator, iterator, __true_type) { }

      void
      _M_destroy_data_dispatch(iterator __first, iterator __last, __false_type)
      { _M_destroy_data_aux(__first, __last); }



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 typedef typename std::__is_scalar<value_type>::__type
   _Has_trivial_destructor;
 _M_destroy_data_dispatch(__first, __last, _Has_trivial_destructor());
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }
# 1477 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 1515 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
# 1547 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 1565 "/usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }

}
# 71 "/usr/include/c++/4.2.1/deque" 2 3


# 1 "/usr/include/c++/4.2.1/bits/deque.tcc" 1 3
# 65 "/usr/include/c++/4.2.1/bits/deque.tcc" 3
namespace std {

  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::copy_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::copy(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::copy_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::copy(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_back_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_back();
      *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t_copy);
          this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
           + 1);
          this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
        }
      catch(...)
        {
          _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_front_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_front();
      *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
          - 1);
          this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
          this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t_copy);
        }
      catch(...)
        {
          ++this->_M_impl._M_start;
          _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, const value_type& __x)
    {
      difference_type __index = __pos - this->_M_impl._M_start;
      value_type __x_copy = __x;
      if (static_cast<size_type>(__index) < size() / 2)
 {
   push_front(front());
   iterator __front1 = this->_M_impl._M_start;
   ++__front1;
   iterator __front2 = __front1;
   ++__front2;
   __pos = this->_M_impl._M_start + __index;
   iterator __pos1 = __pos;
   ++__pos1;
   std::copy(__front2, __pos1, __front1);
 }
      else
 {
   push_back(back());
   iterator __back1 = this->_M_impl._M_finish;
   --__back1;
   iterator __back2 = __back1;
   --__back2;
   __pos = this->_M_impl._M_start + __index;
   std::copy_backward(__pos, __back2, __back1);
 }
      *__pos = __x_copy;
      return __pos;
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_copy_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_copy_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_copy(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_copy_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_copy_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_copy(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

}
# 74 "/usr/include/c++/4.2.1/deque" 2 3
# 70 "/usr/include/c++/4.2.1/stack" 2 3
# 1 "/usr/include/c++/4.2.1/bits/stl_stack.h" 1 3
# 68 "/usr/include/c++/4.2.1/bits/stl_stack.h" 3
namespace std {
# 97 "/usr/include/c++/4.2.1/bits/stl_stack.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class stack
    {

      typedef typename _Sequence::value_type _Sequence_value_type;
     
     
     

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;

    public:




      explicit
      stack(const _Sequence& __c = _Sequence())
      : c(__c) { }




      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      top()
      {
 ;
 return c.back();
      }





      const_reference
      top() const
      {
 ;
 return c.back();
      }
# 177 "/usr/include/c++/4.2.1/bits/stl_stack.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }
# 192 "/usr/include/c++/4.2.1/bits/stl_stack.h" 3
      void
      pop()
      {
 ;
 c.pop_back();
      }
    };
# 212 "/usr/include/c++/4.2.1/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 230 "/usr/include/c++/4.2.1/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x < __y); }

}
# 71 "/usr/include/c++/4.2.1/stack" 2 3
# 8 "../../src/lightweights/gxPainter.h" 2


class gxPainterState;

typedef std::stack< gxPainterState* > StateStack;

struct gxPainterState
{
public:
  int dx, dy;
  gxRect clipArea;
};
# 31 "../../src/lightweights/gxPainter.h"
class gxPainter: public gxObject
{
public:
  gxPainter();



  virtual void PushState();




  virtual void PopState();




  virtual void RestoreState();
# 59 "../../src/lightweights/gxPainter.h"
  virtual void SetTranslate(int dx, int dy) ;
# 68 "../../src/lightweights/gxPainter.h"
  virtual void SetClipArea(gxRect const &aRect);
# 77 "../../src/lightweights/gxPainter.h"
  virtual bool NeedsPainting(gxRect const &aRect) = 0;


  virtual void DrawRectangle(int x, int y, int w, int h) = 0;

protected:



  virtual void RestoreState(gxPainterState *aState);





  virtual gxRect GetClipRect() = 0;






  virtual void Transform(gxRect &aRect);





  virtual void IntersectClipArea(gxRect const &aRect) = 0;
# 115 "../../src/lightweights/gxPainter.h"
  virtual void SetAbsoluteClipArea(gxRect const &aRect) = 0;

  int mTranslateX;
  int mTranslateY;

  StateStack mStateStack;



};
# 7 "../../src/lightweights/gxViewElement.h" 2


class gxRootViewElement;
# 27 "../../src/lightweights/gxViewElement.h"
class gxViewElement: public gxComposite
{
public:
  gxViewElement();
  ~gxViewElement();





  virtual void Paint(gxPainter &aPainter) = 0;
# 48 "../../src/lightweights/gxViewElement.h"
  void Erase();






  virtual gxRect GetBounds() const = 0;







  virtual void TranslateToAbsolute(gxRect &aRect);







  virtual void TranslateToParent(gxRect &aRect);

protected:






  virtual void PaintChildren(gxPainter &aPainter) = 0;





  virtual gxRootViewElement* GetRootViewElement();




  virtual void Repaint();




  virtual void Repaint(gxRect &aRect);

  public: gxViewElement* GetParent() const { return (gxViewElement*)mParent; } protected: gxViewElement* Child(ChildIterator it) { return ((gxViewElement*)(*it)); } virtual void OnAddChild(gxComposite* aChild) { OnAddChild((gxViewElement*)aChild); } virtual void OnAddChild(gxViewElement* aChild); virtual void OnRemoveChild(gxComposite* aChild) { OnRemoveChild((gxViewElement*)aChild); } virtual void OnRemoveChild(gxViewElement* aChild);
};
# 5 "../../src/lightweights/gxVisualViewElement.h" 2





class gxVisualViewElement: public gxViewElement
{
public:
  gxVisualViewElement();
  gxVisualViewElement(const gxRect &aBounds);
  ~gxVisualViewElement();
# 26 "../../src/lightweights/gxVisualViewElement.h"
  void Paint(gxPainter &aPainter);




  gxRect GetBounds() const;




  void SetBounds(gxRect &aNewBounds);
protected:




  virtual void PaintSelf(gxPainter &aPainter) {}




  virtual void PaintChildren(gxPainter &aPainter);






  void Translate(int dx, int dy);


  gxRect mBounds;
};
# 5 "../../src/lightweights/shapes/gxShape.h" 2
# 16 "../../src/lightweights/shapes/gxShape.h"
class gxShape: public gxVisualViewElement
{
public:
  gxShape() {}
  gxShape(const gxRect &aBounds)
    : gxVisualViewElement(aBounds) {}
protected:
  void PaintSelf(gxPainter &aPainter);
  virtual void PaintShape(gxPainter &aPainter) = 0;
};
# 2 "/Development/gefri/src/lightweights/shapes/gxShape.cpp" 2

void gxShape::PaintSelf(gxPainter &aPainter)
{
  PaintShape(aPainter);
}
